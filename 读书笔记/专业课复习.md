# 高数

## 1.驻点、极值点、拐点

- 驻点：一阶导数为零的点。

- 极值点：去心邻域内的函数值都比f(x~0~)小（大），就是极值点。
- 拐点：某点二阶可导，且左右邻域内二阶导变号，就是拐点。
  - **凹凸分界点**

## 2.凹凸性

- 凸函数在开区间上满足二阶导数恒小于0；
- 凹函数在开区间上满足二阶导数恒大于0；

<img src="C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/%E5%87%B9%E5%87%B8%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89.png" style="zoom: 67%;" />

## 3.间断点

- **第一类间断点**：左右极限都存在的间断点。
  - 左右极限值相等的称作“可去间断点”
  - 左右极限值不相等的叫“跳跃间断点”
- **第二类间断点**：左右极限至少有一个不存在的间断点。
  - 左右极限值如果有一个是无穷，称作无穷间断点
  - 反复震荡的叫震荡间断点

## 4.泰勒展开

- **用多项式函数来拟合一个无限可导的复杂函数**。
- 由于多项式函数可以任意次求导，易于计算，且便于求解极值或者判断函数的性质，因此可以通过泰勒公式获取函数的信息，同时，对于这种近似，必须提供误差分析，来提供近似的可靠性。

<img src="C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80.png" style="zoom:80%;" />

***

## 5.极限

> 函数极限

- 存在常数A，**对任意**ε，**总存在**正数δ，**使当** 0 < |x - x~0~| < δ 时，|f(x) - A| < ε。
  - 当x足够趋近于x~0~时，f(x)足够趋近于A。
  - ε：epsilon；     δ：delta。

![](C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90.png)

> 数列极限

- 对于定数a，**对任意**ε，**总存在**正整数N，**使当**n > N时，|a~n~-a| < ε。
  - 当n足够大时，a~n~足够趋近于a。

![](C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90.png)

## 6.可导、可微、连续

- 连续：左极限等于右极限等于函数值。
- 可导：lim f(x~0~+$\Delta$x) - f(x~0~) / $\Delta$x 存在，在x~0~处可导。
- 可微：dy = f'(x~0~) $\Delta$x 。

- 对一元函数而言，可导等价于可微；可导必连续，但连续不一定可导；

- 对二元函数而言：
  - 可微必一阶偏导存在，反之不成立；
  - 可微必连续，反之不成立；
  - 一阶偏导连续则可微，反之不成立；
  - 连续和一阶偏导存在之间没有关系。

## 7.微分中值定理

- 费马引理：x~0~处可导，且f(x~0~)是去心邻域内的极大（小）值，则f'(x~0~) = 0。
- 罗尔中值定理：闭区间连续、开区间可导、区间端点函数值相等，则开区间内至少存在一点ε满足：f‘(ε) = 0。
- 拉格朗日中值定理：闭区间连续、开区间可导，则开区间内至少存在一点ε满足：f‘(ε) = (f(b) - f(a)) / (b - a)。
- 柯西中值定理：对f(x)和g(x)，闭区间连续、开区间可导且g'(x)≠0，则开区间内至少存在一点ε满足：(f(b) - f(a)) / (g(b) - g(a)) = f'(ε) /g'(ε)。
  - 二维平面内在点(g(a), f(a))与点(g(b), f(b))的连线所构成的直线一定与函数曲线(g(x), f(x)), x∈(a,b) 中的一点切线平行。


## 8.梯度

- **梯度**是一个矢量，表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）。
  - **是一个向量，方向是多元函数方向导数取最大值的方向，值是方向导数的最大值。**
- **某点的函数值沿着梯度的方向增加的最快，逆着梯度的方向函数值减小的最快。**

![](C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/%E6%A2%AF%E5%BA%A6.png)

- 函数在任意方向上的方向导数是在该方向上的切线的斜率。

## 10.级数、收敛、绝对收敛

- 级数：将数列的项依次用加号连接起来的函数。
- 收敛：当n趋于无穷时，数列S~n~有极限为S，则称级数收敛。
  - S~n~是级数的部分和，是前n项的和。
- 绝对收敛：原级数收敛，若它各项的绝对值构成的级数收敛，则称级数绝对收敛。
- 条件收敛：原级数收敛，若它各项的绝对值构成的级数发散，则称级数条件收敛。

## 11.傅里叶级数

- 任何周期函数都可用正弦级数或余弦级数来表示。



# 线代

## 1.行列式

- 以行向量为邻边的n维图形的体积。
- 求解方法：行列式的值等于行列式某行（列）元素分别乘其对应的代数余子式再求和。
- 转置相等、换行变号、乘数乘行、倍加相等、拆分分行（列）。
- 零性质：一行（列）全零、两行（列）成比例。
- |AB| = |A||B|; |kA| = k^n^|A|

## 2.矩阵的秩

- 最高阶非零子式的阶数
  - 初等变换不改变矩阵的秩，所以可以化为行阶梯矩阵，求秩。

- 线性无关向量的个数

## 3.伴随矩阵

- 矩阵各元素替换成它的代数余子式，然后做转置就能获得原矩阵的伴随矩阵。
- 矩阵的逆 等于 伴随矩阵  ÷  矩阵行列式的值
  - |A|E = AA* = A*A
  - A^-1^ = A^*^ / |A|

## 4.线性相关

- 线性相关：对于m个n维向量a~1~,a~2~,...a~m~，存在一组不全为零的数k~1~,k~2~,...k~m~，使 k~1~a~1~+k~2~a~2~+...k~m~a~m~=0;

- 线性无关：不存在不全为零。

## 5.极大线性无关组

- 极大线性无关组：首先是线性无关组，齐次是能表出方程组中的其他向量。
- 向量组极大线性无关组的向量个数称为该向量组的秩。
- R(A) = R(A的行向量组) = R(A的列向量组)
- 求解方法：向量组矩阵行最简形，所有非零行第一个非零元素所在的列组成的列向量组就是极大线性无关组。
  - 初等变换前后，向量组的线性相关性不改变。


## 6.向量空间的基

- 向量空间：满足加法封闭性和数乘封闭性的向量集合。

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\向量空间的基.png)

## 7.齐次、非齐次线性方程组的解

- 求解方法：通过初等行变换转换为行最简形：【A, b】——>【C, d】。Ax=b和Cx=d有相同的解。

> 齐次线性方程组

- 一定有解

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\齐次线性方程组有解的条件.png" style="zoom: 67%;" />

- 解向量的线性组合还是解向量。所以，所有解向量构成的集合V是一个向量空间。
- 基础解系：基础解系是指方程组的解集的极大线性无关组。是解空间的基。
- n-r是自由变量的个数、基础解系的size、解空间的维数。
- 齐次线性方程组的通解：基础解系的任意线性组合：k~1~x~1~ + k~2~x~2~ + ... k~m~x~m~，其中k~i~为任意常数。

> 非齐次线性方程组

<img src="C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/image-20220629195049921.png" alt="image-20220629195049921" style="zoom: 80%;" />

- $\eta$~1~、$\eta$~2~是非齐次线性方程组的解，则$\eta$~1~-$\eta$~2~是对应齐次线性方程组的解。
- $\eta$~1~是非齐次线性方程组的解，$\xi$是对应齐次线性方程组的解，则$\eta$~1~+$\xi$是非齐次线性方程组的解。
- 非齐次线性方程组的通解：对应齐次线性方程组的通解+非齐次线性方程组的特解。

## 8.特征值和特征向量

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\特征值和特征向量.png" style="zoom: 67%;" />

- 特征方程：|A-$\lambda$E|=0；
- 特征多项式：f($\lambda$)=|A-$\lambda$E|;
- 一个特征值可对应多个特征向量，一个特征向量只能有一个特征值。
- 属于不同特征值的特征向量线性无关。
- **求解特征值**：解特征方程
- **求解特征向量**：解方程组|A-$\lambda_{i}$E|x=0
- **迹**：n个特征值的和 == 矩阵主对角线元素的和
- **A矩阵的行列式** = n个特征值的积
- 相似矩阵的秩、特征值、行列式的值、特征方程的值相等。

> 特征值和特征向量的意义

- 如果一个向量投影到方阵对应的空间中只发生伸缩变换，而不发生旋转变换，那么该向量就是这个方阵的一个特征向量，伸缩比例就是特征值。
- 多维矩阵会把向量沿着多个方向拉伸，有的方向可能拉伸幅度很小，而有的很大，我们只需要保留幅度大的即可达到降维的目的。

## 9.相似对角化

- n阶矩阵A存在对角相似矩阵，则称A可相似对角化。P^-1^AP = $\wedge$。
  - $\wedge$矩阵对角线元素为A的特征值。
  - P矩阵为特征向量矩阵。
- 可对角化条件：（**有n个线性无关的特征向量**）、（每个特征值的几何重数都等于代数重数）
- 实对称矩阵必可相似对角化，且P矩阵是正交矩阵。
  - 实对称矩阵的特征值是实数、特征向量是实向量。实对称矩阵不同特征值的特征向量两两正交。几何重数等于代数重数。


## 10.二次型

- n元二次型：n元变量x~1~,x~2~,...x~n~的二次齐次多项式。
  - A是对称矩阵

![image-20220629203910363](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\二次型的定义.png)

- 合同二次型指出了同一个二次型在可逆线性变化下的两种不同状态的联系。

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\合同二次型.png" style="zoom: 67%;" />

- 二次型的标准型：只有平方项，没有交叉项。
  - 二次型化为标准型，要求B矩阵是对角阵。
  - 实对称矩阵必可相似对角化：可以得出，实二次型存在正交的P矩阵满足 P^T^AP=$\wedge$，使之可标准化。P矩阵就是A的特征向量组。

- 二次型化为标准型，其正项个数p和负项个数q都是不变的，p称为正惯性指数，q称为负惯性指数。秩r=q+p。

## 9.正定矩阵

- 正定矩阵：n元二次型，对任意 **x ≠ 0**，均有x^T^Ax > 0，则二次型对应的矩阵是正定矩阵。
  - 特征值均大于0
  - p = n（正惯性指数为n）
  - 顺序主子式均大于0
  - A 合同于 E
  - R(A) = n
  - 主对角线元素全为正数
  
- 半正定矩阵：n元二次型，对任意 **x**，均有x^T^Ax >= 0，则二次型对应的矩阵是半正定矩阵。

## 10.矩阵的等价、合同、相似

- 矩阵A与矩阵B等价：存在可逆矩阵P、Q，使B=PAQ；即通过初等变化，能使A转换为B。
  - 秩相同
- 矩阵A与矩阵B合同：存在可逆矩阵P，使B=P^T^AP。
  - 秩相同，且正负惯性指数相同。
- 矩阵A与矩阵B相似：存在可逆矩阵P，使B=P^-1^AP。
  - 秩、正负惯性指数、特征值相同。
- 相似必等价、合同必等价、实对称矩阵相似必合同。

## 11.n阶矩阵可逆的充要条件

- AB = E (= BA)： A与B互逆

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\n阶矩阵可逆的充要条件.png)

## 12.矩阵的逆

- 矩阵的逆是唯一的。 (A^-1^)^-1^ = A 。 (AB)^-1^ = B^-1^A^-1^。 (A^T^)^-1^ = (A^-1^)^T^。 

- 初等变换：换行、倍加、倍乘。
- 逆矩阵的求法：
  - 【A | E】 ——> 【E | A^-1^】
  - 矩阵的逆 等于 伴随矩阵  ÷  矩阵行列式的值。 A^-1^ = A^*^ / |A|

## 13.克莱姆法则

- 若非齐次线性方程组的系数矩阵可逆（非奇异），即系数行列式 D≠0，则线性方程组有唯一解，其解为：
  - x~j~ = D~j~ / D；
  - 其中D~j~是把D中第j列元素对应地换成常数项而其余各列保持不变所得到的行列式。

## 14.范德蒙行列式

![](C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/%E8%8C%83%E5%BE%B7%E8%92%99%E8%A1%8C%E5%88%97%E5%BC%8F.png)

- 范德蒙行列式的值：$\prod_{j>i}(x_{j}-x_{i})$。

## 15.正交

- 正交向量：两个非零向量内积为0。

  - 内积：俩列向量$\alpha$、$\beta$，内积($\alpha$, $\beta$) = $\alpha$^T^$\beta$ = $\beta$^T^$\alpha$
- 正交向量组：一组两两正交且非零的向量组。
- 标准正交基：单位正交基。
  - 每个向量都是单位向量。
- 正交矩阵：如果n阶 **实** 对称矩阵A，满足A^T^A = E，则A是正交矩阵。A^T^ = A^-1^。
  - |A|=±1、A做上标运算后还是正交矩阵、正交矩阵的积是正交矩阵、行（列）向量组是R^n^的一组标准正交基；
  - 正交变换的内积、长度、夹角不变。

## 100.一些琐碎

- 反对称阵：A^T^ = -A
- 分块矩阵的加、乘运算和常规矩阵是类似的。
- 行阶梯矩阵、行最简形。
- 任何可逆矩阵都能由单位矩阵经过若干次初等变换得来。
- 对于n阶方阵A： 不可逆 <==> |A|=0 <==> R(A)<n <==> 向量组线性相关；可逆 <==> |A|≠0 <==> R(A)=n <==> 向量组线性无关。
- 向量组等价 == 两个向量组能相互表出。
  - 向量组和它的极大线性无关组等价；
  - 同一向量组的任两个极大无关组等价；
  - 向量组等价则秩相等；

- 向量组a~1~,a~2~,...a~m~可由向量组b~1~,b~2~,...b~m~线性表出，则 R(A) < R(B)；


- 基变换与线性变换。

  - 线性映射：是从一个向量空间V到另一个向量空间W的映射且保持加法运算和数乘运算（线性运算）。
  - 线性变换：线性空间V到其自身的线性映射。
  - 基变换：向量空间的两个基通过过渡矩阵相互转换的过程。同时意味着向量坐标的转换。

    - 唯一的蕴含一个可逆线性变换。
- n重特征值最多有n个线性无关的特征向量。

  - 代数重数 大于等于 几何重数。
- 特征分解：矩阵 分解为由其 特征值 和 特征向量 表示的矩阵之积的方法
  - 参照相似对角化。
- 



# 概率论

## 1.事件的关系与运算

> 关系：包含、相等、相容、互斥、对立

- 事件A发生必导致事件B发生，则B包含A。

- A、B事件相互包含，则A=B。
- A交B为空集，A、B事件互斥。
	- 不能同时发生。
- A交B不为空集，A、B事件相容。
	- 可能同时发生。
- A、B事件互斥且必有一个发生，A、B事件对立。
	- 有且只有一个发生。

> 运算：并、差、交

- "A、B事件同时发生"的事件，A交B。
- "A、B事件最少有一个发生"的事件，A并B。
- "A事件发生而B事件不发生"的事件，A差B。

## 2.条件概率

![](C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F.png)

## 3.全概率公式

A~i~交集是空集，并集是全集，P(A~i~) > 0，对任一事件B：

![](C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F.png)

## 4.贝叶斯公式

![](C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F.png)

- 后验概率 = 先验概率 * **标准化似然度**。
  - 先验概率：事情未发生，只根据以往数据统计，分析事情发生的可能性。
  - 后验概率：事情已经发生，想要计算这件事发生的原因是由某个因素引起的概率。

- 可以理解成通过观察到的知识（似然度），更新概率（先验概率 => 后验概率）

## 5.相互独立

- P(AB) = P(A) P(B)

## 6.正态分布

- 当在**大量随机变量上重复很多次实验时，它们的分布总和将非常接近正态分布**。（中心极限定理）

- 方差越大，越矮胖；方差越小，越瘦高。

## 7.大数定律

> 当样本数足够大时：

- **切比雪夫大数定律**：样本均值依概率收敛于数学期望
  - 相互独立的随机变量序列，样本均值依概率收敛于数学期望

- **伯努利大数定律**： 频率趋近于概率
  - n重伯努利实验中事件A发生的频率，依概率收敛于事件A发生的概率

- **辛钦大数定律**：随机变量均值趋近于期望
  - 独立同分布随机变量序列的均值，依概率收敛于期望

<img src="C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B.png" style="zoom:80%;" />

## 8.中心极限定理

- 描述**随机变量序列部分和分布渐近于正态分布的一类定理**。

## 9.最大似然估计法

- 对未知参数θ进行估计时，在该参数可能的取值范围I内进行选取,用使“样本获取观测值x1,x2...xn“概率最大的theta尖儿做theta的估计。有利于x~1~,x~2~...x~n~出现。
- 利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值。
- 方程的解只是一个估计值，只有在样本数趋于无限多的时候，它才会接近于真实值。

> 步骤

- 求概率函数（密度）的联合函数（密度）
- 取对数
- 求导
- 解似然方程

## 10.各种分布

### 10.1离散型

> 0-1分布B(1,p)

- P{X=1} = p;	P{X=0} = 1-p;

> 二项分布B(n,p)

- n重伯努利实验中事件A发生的次数，P{X=k};

> 泊松分布P(lambda)

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\泊松分布.png" style="zoom:80%;" />

- 泊松分布适合于描述 **单位时间内独立随机事件发生的次数** 的概率分布。
- 某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数

> 几何分布G(p)

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\几何分布.png" style="zoom: 67%;" />

> 超几何分布H(n, N, M)

- 不放回抽样的概率分布
- N个物品里有M个想要的物品，抽n次，抽中k次的概率分布

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\超几何分布.png" style="zoom: 67%;" />

### 10.2连续型

> 均匀分布U(a, b)

- 在相同长度间隔的分布概率是等可能的。

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\均匀分布.png)

> 指数分布E(lambda)

- 泊松过程中的事件之间的时间的概率分布。即事件以恒定平均速度连续且独立地发生的过程
- **表示独立随机事件 发生的时间间隔**的分布概率

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\指数分布.png)

> 正态分布

- 身高、血压、成绩的群体分布呈正态分布

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\正态分布表示.png)

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\正态分布.png)



## 11.联合分布、边缘分布

- 离散型随机变量：概率分布P{X=x~i~} 的 累积 -> 分布函数
- 连续型随机变量：概率密度f(x) 的 积分 -> 分布函数

> 联合分布函数概念

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\联合分布函数概念.png)

> 边缘分布函数概念

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\边缘分布函数概念.png)

### 11.1离散型随机变量的概率分布、边缘分布和条件分布

> 联合分布函数

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\离散型联合分布函数.png)

> 边缘分布概率

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\离散型边缘分布.png)

- 神经网络的神经元互联，在计算各自的参数时，会使用边缘分布计算得到某个特定的参数。

> 条件分布概率

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\离散型条件分布.png)

- 条件分布概率 = 联合分布概率 / 边缘分布概率

### 11.2连续型随机变量的概率密度、边缘概率密度和条件概率密度

> 联合分布函数

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\连续型联合分布函数.png)

> 边缘概率密度

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\连续型边缘概率密度.png)

> 条件概率密度

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\连续型条件概率密度.png)

## 12.一些概念

- 期望：试验中每次可能结果的概率乘以其结果的总和；描述随机试验中，随机变量的平均值。

- 方差：用来计算每一个变量（观察值）与总体均数之间的差异。
  - 偏差的平方的期望。E[(X-E(X))^2^] = E(X^2^)-[E(X)]^2^。

- 协方差：用于衡量两个变量的**总体误差**。
  - E[(X-E(X))(Y-E(Y))] = E(XY) - E(X)E(Y)

- 相关系数：研究变量之间**线性相关程度**的量。
  - 相关系数 = 协方差 / 标准差的积。
  - $\rho$ > 0 正相关；< 0 负相关； = 0 不相关。
  - 绝对值越大，相关性越大。




# 离散

## 0.离散学了啥

- 数理逻辑、集合论、代数系统、图论。
  - 数理逻辑：用数学方法来研究推理的规律科学。
  - 代数系统：非空集合S和S上的k个运算组成代数系统。代数系统=非空集合S+运算+代数常数


## 1.全序和偏序

- **偏序**：集合内只有部分元素之间在这个关系下是可以比较的。
  - 集合A上的二元关系R，满足**自反性**，反对称性，传递性。
  - 复数集的比较就是偏序的。
  
- **全序**：集合内任何一对元素在在这个关系下都是相互可比较的。
  - 满足**完全性**，反对称性，传递性。
  - 完全性：a ≤ b 或 b ≤ a。
- **良序**：设集合 (S ,≤) 为一全序集，≤是其偏序关系。对**任意** 的S 的**非空子集**都有在其序下有**最小元素**，则称≤为**良序关系**，(S ,≤) 为良序集。

## 2.映射

- **映射**是指两个集合之间的一种对应关系。设X,Y是两个给定的集合，若按照某种规则f，使得**X中的每一个元素**，都可以在**Y中找到唯一的元素**与之对应，则称这个对应规则f是集合X到集合Y的一个映射。
- **单射**：对X中的任意两个不同元素 **x~1~不等于x~2~**，它们的像y~1~和y~2~也满足 **y~1~不等于y~2~**，则为单射。
- **满射**：如果映射f满足 f(X)=Y 则称f为满射。换句话说也就是 **集合Y中所有元素都被映射到了**。
- **双射**：一个对应关系如果既是单射又是满射，则我们称这一对应关系为双射（一一对应）。

## 3.范式

- **文字**：命题变元及其否定统称为文字。（例：q和否p）

- 简单析取式：有限个文字构成的析取式

- 简单合取式：有限个文字构成的合取式

- **析取范式**：有限个简单合取式构成的析取式

- **合取范式**：有限个简单析取式构成的合取式
  - 析取范式和合取范式统称为范式
  - 范式存在定理：每个命题公式都存在与之等价的析取范式和合取范式

- **主析取范式**：每个简单合取式都含有全部变元的析取范式
  - 其中每个简单合取式称为极小项

- **主合取范式**：每个简单析取式都含有全部变元的合取范式
  - 其中每个简单析取式称为极大项

- **主范式唯一性定理**：任何命题公式都存在唯一与之等值的主析取范式与主合取范式

## 4.集合的幂集

- 集合A的所有子集构成的集合，称为A的幂集
- 当集合A为有限集时，A的幂集中元素的个数等于A中元素个数的2次幂

## 5.有序对和笛卡尔积

- x，y按一定顺序排列成的二元组叫有序对。<x,y>和<y,x>
- 令A和B是任意两个集合，若有序对的第一个成员是A的元素，第二个成员是B的元素，所有这样的有序对集合，称为集合A和B的笛卡尔乘积。

***

## 6.什么集合？

- 由离散个体构成的整体称为集合，称这些个体为集合的元素。

- 集合元素的性质：无序性、相异性、确定性、任意性

## 7.等价关系、等价类

- 等价关系：设R 为非空集合 A上的一个关系，如果 R是**自反的**、**对称的**和**传递的**，则称 R 为 A 上的等价关系。

- 等价类：设 R是集合 A 上的等价关系，{x| xRa} 叫做 a的等价类。
  - 与a有等价关系的所有元素组成的集合

## 8.函数

- 函数：非空数集到非空数集的映射，只能是一对一映射或多对一映射。

## 9.集合、关系与函数之间的关系？

- 集合是基础。

- 在集合之上建立关系，关系建立集合与集合间的联系。

- 函数是一种特殊的关系.

## 10.哈密顿图

- 哈密顿图：能走出一条通过每个**结点**一次且仅一次的回路的图。
- 只有一个结点的图（平凡图）是哈密顿图。

## 11.欧拉图

- 欧拉路径：图G中经过每条边一次且仅一次的路径。
- 欧拉回路：图G中经过每条边一次且仅一次的回路。
- 欧拉图：存在欧拉回路的图称为欧拉图。
- 只有欧拉路径，没有欧拉回路的称为半欧拉图。

### 11.1 性质与定理

- 首先将图G中的孤立点（度为0）去掉，这样做不影响欧拉回路的存在。

> 对无向图

- **定理1**：无向图G为欧拉图，当且仅当G为 连通图 且 所有顶点的度都是 偶数。
  - 必要性：欧拉回路经过所有边且是回路，所以是连通图。所有顶点在无重复回路上都是从一条边进入，另一条边离开，所以度都是偶数。
  - 充分性：先证明有回路，再证明边数最多的无重复回路C是欧拉回路（即覆盖全部边）。
    - 握手定理d(V) = 2|E|; 若无回路，连通图G就是G树，|E| = |V| - 1; 又有顶点度数是正偶数；所以 d(V) >= 2|V|。矛盾，所以有回路。
    - 边数最多的无重复回路C如果不是欧拉回路，那么至少有一条边，在回路外，设该边的一端是v~0~。如果该边是自环，那该自环加入C会使回路更大，与最大回路矛盾。如果不是自环，是e(v~0~, v~1~)，因为顶点度数是偶数，则一定还存在另一个回路使v~0~度数为偶数。那该回路加入C会使回路更大，与最大回路矛盾。所以最大回路C就是欧拉回路。
- **推论1**：无向图G为半欧拉图，当且仅当G为连通图且除了两个顶点的度为奇数之外， 其它所有顶点的度为偶数。

> 对有向图

- **定理2**：有向图G为欧拉图，当且仅当G的 基图连通，且所有顶点的 入度等于出度。
- **推论2**：有向图G为半欧拉图，当且仅当G的基图连通，且存在顶点u的入度比出度大1 、v的入度比出度小 1，其它所有顶点的入度等于出度。

> 一些性质

- 性质1：设C是欧拉图G中的一个简单回路，将C中的边从图G中删去得到一个新的图G',则 G'的每一个极大连通子图都有一条欧拉回路。
  - 若G为无向图，则图G′的各顶点的度为偶数；若G为有向图，则图 G′的各顶点的入度等于出度。

- 性质2：设 C1、C2是图G的两个没有公共边，但有至少一个公共顶点的简单回路，我们可以将它们合并成一个新的简单回路 。

> 欧拉图算法

- 在图G中任意找一个回路C；
- 将图G中属于回路C的边删除； 
- 在残留图的各极大连通子图中分别寻找欧拉回路；
- 将各极大连通子图的欧拉回路合并到C中得到图G的欧拉回路。



## 12.命题逻辑，谓词逻辑

- **命题逻辑可以看成是谓词逻辑的子集，0元谓词逻辑公式就是命题逻辑公式。**

- 命题逻辑无法分解命题的内部结构及命题之间的内在关系。

- 谓词逻辑是命题逻辑的推广，把命题逻辑中的原子句子分解成项，变元，谓词，量词。
  - 谓词：用以描述个体的性质或个体间关系的部分。
  - 量词：全称量词、存在量词。

## 13.覆盖和划分

- 把A拆分为几个非空子集A~1~,A~2~,...,A~m~的并集A=A~1~∪A~2~∪...∪A~m~，那么S={A~1~,A~2~,...,A~m~}称为集合A的一个覆盖。
- A的划分是在覆盖的基础上，还要求任意两个子集的交集是空集。

## 14.怎么判断两个无穷集合的大小？

对无限集，通过建立一一对应的方法可以比较它们元素个数的大小（在集合论中称为势），以整数集 Z 和偶数集 A 为例，如果将 Z 中的每一个元素都乘以 2 ，则都可以在 A 中找到对应的偶数元素，即 Z 和 A 中的元素是一一对应的，也就是说这两个集合是等势的。值得注意的是，偶数集合是整数集合的一部分，但它包含的元素个数却跟整数集合一样多。

## 15.概念

- 二元关系：集合为空集或所有元素都是有序偶。
  - xRy或<x,y>∈R，表示x和y有R关系。

- 命题：能判断真假的陈述句。
- 命题分类：原子命题和复合命题。
  - 原子命题：不能再分解为更简单命题的命题。
  - 复合命题：由原子命题通过命题联结词构成的命题。

- 命题联结词：非、合取、析取、蕴含、等价。
- 握手定理：
  - 在任何有向图图中，所有顶点的度数之和等于边数的2倍，所有顶点的入度之和等于所有顶点出度之和，等于边数。
  - 无向简单图，同样所有顶点的度数之和等于边数的2倍。

- 图的同构：两个图的结点和边分别存在着一一对应，且保持关联的关系。



# 数据结构

## 0.什么是数据结构？为什么要有数据结构？

- 数据结构指数据和数据之间的关系。相互之间存在一种或多种特定关系的数据元素的集合。
- 包括：逻辑结构、物理结构和数据运算。
	- 逻辑结构：线性结构、非线性结构。
		- 线性结构：串、（线性表：栈、队列、数组）。
		- 非线性结构：树、图、集合。
	- 物理结构：顺序存储、链式存储、索引存储和散列存储。
	- 数据运算：运算定义和实现（逻辑和物理）
- 通常情况下，精心选择的数据结构可以带来**更高的运行或者存储效率**。数据结构往往同高效的检索算法和索引技术有关。

## 1.堆(heap)和栈(stack)的区别与联系

### 程序内存中的堆栈

- **栈(Stack) 由编译器/操作系统自动分配释放** ，用于存放函数的参数值、局部变量等。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量。
- **堆(Heap) 由开发人员分配和释放**， 若开发人员不释放，程序结束时由 OS 回收。操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。

### 数据结构中的堆栈

- 数据结构里的堆和程序内存堆没有关系。
- 程序内存栈就是用栈实现的。

## 2.树和图的关系

- 树是**有向无环连通图**，是图的子集。
- 树是层级结构（一对多），图是网络结构（多对多）。

## 3.线性表

- 具有**相同数据类型**的n个数据元素的**有限序列**。前驱、后继、顺序性。
- 是一种逻辑结构。
- 实现方式即存储结构有：顺序表和链表。
	- 顺序表：逻辑相邻的数据元素物理也相邻。随机访问但是连续存储。访问
	- 链表：通过指针将数据元素联系起来。不要求物理相邻但是要指针。增删

## 4.栈和队列

- 操作受限的线性表
- 栈：表达式求值、递归
- 队列：层次遍历、消息队列、缓冲区

## 5.树

- 一个根节（结）点，剩余节点可以分为多个不相交的有限集，其中每个集合又是一棵树，成为根的子树。
- 特点：除根节点外，所有节点只有一个前驱，有零个和多个后继。

## 6.二叉树

- **二叉树**：每个节点最多有两个子树，且子树有左右之分。由根节点和左右子树构成。左右子树分别为二叉树。
- **满二叉树**: 树高h，有2^h^-1个节点的二叉树。
- **完全二叉树**：对应相同高度满二叉树 缺失最下层最右侧连续节点的二叉树。
- **二叉搜索树**（BST）：左子树所有节点关键字 < 根节点关键字 < 右子树所有节点关键字。左右子树分别为一棵二叉搜索树。
- **平衡二叉搜索树**（AVL）：树上任一结点的左子树和右子树的深度差不超过1。

## 7.图

- 图不能为空图，顶点集一定非空。
- **子图**：对于图G' (V', E') 和图G (V, E) , V'是V的子集，E'是E的子集，则G'是G的子图。
- **生成子图**：子图但节点集相同。
- **完全图**：无向图任意两顶点间存在边；向向图任意两顶点间存在方向相反的两条边。
- **连通图**：任意俩顶点间连通。
- **极大连通子图**：
	- 无向连通图的极大连通子图就是它本身。
	- 无向不连通图又可以分为若干个连通子图。其中有这样的连通子图，它包含了图中尽可能多的顶点以及尽可能多的边，以至于它再加上一个点或者边之后它就不连通了，此时这个图就是极大连通子图。
- **极小连通子图**：
	- 有最少边的连通子图。
- **连通分量**：无向图的极大连通子图。
- **强连通图**：图中任一对顶点v、w都有，v到w有路径且w到v有路径。
- **强连通分量**：有向图的极大连通子图。
- **生成树**：包含图中全部顶点的极小连通图。
- **最小生成树**：边权值之和最小的生成树。

## 8.Prim算法

- 任选一个顶点加入树T。
- 选择一个和当前顶点集距离最近的顶点，加入树T。
- 直至所有顶点加入T，则T为最小生成树。
- 适用于稠密图

## 9.Kruskal算法

- 按权值递增的顺序依次选择边，若不构成回路，则加入树T中。
- 直到含有n-1条边。
- 可以用并查集来检测两个节点是否属于同一个集合。
- 适用于边稀疏而顶点较多的图

## 10.Dijkstra、Bellman-Ford、Floyd

- Dijkstra是贪心：每次都取“到源点距离最小”的点，然后用该点松弛源点到其余点的距离。不能是负权图。
  - 单源点最短路径

- Bellman是DP：每次都松弛所有边。可以是负权图。
  - 单源点最短路径

- Floyd是DP：最开始只允许经过1号顶点进行中转，接下来只允许经过1号和2号顶点进行中转......允许经过1~n号所有顶点进行中转，来不断动态更新任意两点之间的最短路程。可以是负权图，但不能有负权环。
  - 多源最短路径


## 11.AOV网和AOE网、拓扑排序

> AOV(activity on vertex)：顶点是活动。

- 用DAG（Directed Acyclic Graph）图表示一个工程。顶点表示活动，边<Vi, Vj>表示活动i先于活动j发生。则称这种图为AOV网

> 拓扑排序

- 对DAG（有向无环图）顶点排序，若存在从顶点A到顶点B的路径，则排序中顶点B出现在顶点A的后面。
- 排序过程：从AOV网中选择一个入度为0的顶点输出，然后从有向图中删除该顶点，并删除以此顶点为起点的边，继续重复此步骤，直到输出全部顶点或AOV网中不存在入度为0的顶点为止。
- 排序过程2：dfs函数弹栈时，将元素压入元素栈中。

> AOE(activity on edge)：边是活动。

- 在带权有向图中，以顶点为事件，有向边为活动，边上权值为活动开销，称为AOE网。
- AOE网允许并行，路径长度最大的路径称为关键路径。

## 12.B树（多路平衡搜索树）

- B树的阶：所有结点孩子个数的最大值。
- B树是满足如下特征的m叉树：
	- 每个结点最多有m棵子树，即最多有m-1个关键字。
	- 根节点如果不是终端结点，则最少有两棵子树。
	- 除根节点外，所有非叶节点至少有m/2（向上取整）棵子树。
	- 所有叶结点出现在同一层次，且不带信息（空节点）
	- 非叶结点结构如下：

<img src="C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/B+%E6%A0%91%E9%9D%9E%E5%8F%B6%E8%8A%82%E7%82%B9%E7%89%B9%E5%BE%81.png" style="zoom:80%;" />

- 从根节点开始向下描述：
  - 根节点至少有两棵子树
  - 非叶节点有m/2棵到m棵子树，关键字比分叉少一，某关键字左分叉指向子树的关键字小于它，右分叉指向子树的关键字大于它。
  - 叶结点是空节点，在同一层次。
  - 所有非叶节点都存储记录的存储地址。

> 数据库索引用到B树的原因

- 用B树存储数据索引，磁盘存取次数与B树的高度成正比。结点个数很大的情况下，B树的高度远小于二叉树，可以解决IO开销过大的问题。

## 13.B+树

<img src="C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/B+%E6%A0%91%E7%89%B9%E5%BE%81.png" style="zoom:80%;" />

- 从根节点开始向下描述：
  - 根节点至少有两棵子树
  - 非叶节点有m/2棵到m棵子树，关键字和分叉数相等，关键字对应分叉指向子树的关键字小于它
  - 叶结点包含全部关键字，相邻叶结点按大小顺序互相链接。
  - 所有非叶节点只存储指向子节点的指针，不存储记录的存储地址。

> B+树和B树的区别

- 非叶节点关键字和子树的数量
- 非叶节点是否存储记录的存储地址

## 14.散列表

> hash函数

- 直接寻址法：取关键字的某个线性函数值为散列地址。
- 数字分析法
- 平方取中法
- 随机数法
- 除留余数法

> 冲突解决

- 开放定址法：空闲单元既向同义词开放，又向非同义词开放。发生哈希冲突时，通过再次进行函数计算，来获得空闲地址。
	- 线性探测法
	- 平方探测法
	- 再散列
- 拉链法：同义词存在单链表里。

## 15.NP问题

- P问题：能在多项式时间内解决的问题
- NP问题：能在多项式时间内验证答案正确性的问题，不一定能在多项式时间内解决
- NP难：所有的NP问题都能在多项式时间内约化到它，但是他不一定是一个NP问题
- NP完全：是NP问题，且是NPH问题

## 16.红黑树

- 红黑树是2-3树（2-3-4树）的一种实现，阶数为3（4）的B树。
- 算法4的实现是左倾红节点（红节点为左节点）

> 经典的五条规则

- 节点不是黑色，就是红色（非黑即红）

- 根节点为黑色

- 叶节点为黑色（叶节点是指末梢的空节点 `Nil`或`Null`）

- 一个节点为红色，则其两个子节点必须是黑色的（根到叶子的所有路径，不可能存在两个连续的红色节点）
  - 没有连续的红色节点

- 每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）
  - 完美黑色平衡

> 应用场景

- Java的TreeMap、TreeSet、HashMap(JDK1.8)；
- linux底层的CFS进程调度算法中，vruntime使用红黑树进行存储；
- 多路复用技术的Epoll，其核心结构是红黑树 + 双向链表

> 特点

- 从二叉搜索树 → AVL，严格控制左右子树高度差，避免二叉搜索树退化成链表（时间复杂度从O(log2N)退化成O(N)）
- 从AVL → 红黑树，牺牲严格的平衡要求，以换取新增/删除节点时少量的旋转操作，平均性能优于AVL；通过红黑规则，保证在最坏的情况下，也能拥有O(log~2~N)的时间复杂度。



# 操作系统

## 0.什么是操作系统

- 对应用程序员来说，操作系统是一个扩展机器，它抽象出更好的接口，隐藏了与硬件交互的细节，使计算机的使用更加简单。
- 对操作系统内核开发人员来说，操作系统是一个资源管理器，它在时间和空间上复用硬件资源，是一个合作者。
- 操作系统是控制和管理计算机软硬件资源，合理组织计算机的工作流程，方便用户使用的程序集合。

> 功能

- **进程管理、内存管理、I/O管理、文件管理、用户接口。**

## 1.进程和线程

> 概念

- 进程：正在运行的程序
- 线程：正在运行的代码片段

> 内部结构

- **进程** 包含代码段、数据段、堆栈段、地址空间、PCB、程序计数器(PC)和寄存器
  - PCB里存了进程的ID、进程信息(PC、PSW、register、用户栈指针)、调度信息（进程状态，进程的优先级）、控制信息（程序的数据的地址，资源清单）等。
- **线程** 拥有自己的栈、程序计数器和TCB，与其他进程共享代码段、数据段、地址空间

> 二者的区别

- 线程属于进程，线程更加轻量级（创建、切换和撤销代价小）
- 内部结构不同
- 内核态下，线程就是进程。用户态下，线程属于进程

> 进程的三种状态

- 运行、阻塞、就绪
- 状态转换（I/O和调度）

> 有了进程为啥还要有线程？

- 进程**并发执行**时，如果某个进程在执行过程中阻塞了，那么整个进程就会挂起。而以线程作为并发执行的基本单位，进程的某个线程挂起，其他线程还能继续执行。
- 从资源角度讲，启动一个新进程需要分配独立地址空间、代码段、数据段、堆栈。而线程间**共享**地址空间、代码段、数据段，**轻量级**。
- 线程切换效率也高于进程。
- 从**通信**机制讲，进程间地址空间独立，需要IPC方式来通信。线程间有共享的地址空间，通信方便。

## 2.进程间的通信方式

> 共享存储器系统

- 基于**共享数据结构**的通信方式（仅适用于传递相对少量的数据，通信效率低，属于低级通信）
- 基于**共享存储区**的通信方式

> 管道通信系统

- 管道是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件（pipe文件）
  - Linux上的管道就是一个操作方式为文件的**内存缓冲区**

- 管道机制需要提供一下几点的协调能力：
  - 互斥，即当一个进程正在对pipe执行读/写操作时，其它进程必须等待
  - 同步，当一个进程将一定数量的数据写入，然后就去睡眠等待，直到读进程将数据取走，再去唤醒。读进程与之类似
  - 确定对方是否存在

> 消息传递系统

- 直接通信方式：发送进程利用OS所提供的发送原语直接把消息发给目标进程
- 间接通信方式：发送和接收进程都通过共享实体（邮箱）的方式进行消息的发送和接收

> 客户机服务器系统

- 套接字 – 通信标识型的数据结构是进程通信和网络通信的基本构件
  - 基于文件型的（当通信进程都在同一台服务器中）其原理类似于管道
  - 基于网络型的（非对称方式通信，发送者需要提供接收者命名。通信双方的进程运行在不同主机环境下被分配了一对套接字，一个属于发送进程，一个属于接收进程）
- 远程过程调用和远程方法调用

> 本机：共享存储器、操作系统发送原语、管道。 远程：消息队列、RPC、Socket通信

## 3.同步和互斥

- **同步**：指进程之间的一种协调配合关系，它表现在**进程执行顺序**的规定上。
  - 用来保证某种事件的顺序发生或不发生。

- **互斥**：避免两个或多个进程同时进入临界区。

## 4.进程调度的衡量标准？进程调度算法

> 衡量标准

- **响应时间**：客户发出请求到得到响应的整个过程的时间
  - 交互式系统

- **周转时间**：一个作业从提交到终止间的时间
  - 批处理系统，下同

- **CPU利用率**：1-p^n^，p是进程I/O时间和待在内存里的时间之比，n是进程数。

- **吞吐量**：单位时间的作业量

> 进程调度算法

- 批处理系统：
  - 先来先服务：进程按它们请求CPU的顺序使用CPU。
  - 最短作业优先：所有作业同时启动时，该算法最优。
  - 最短剩余时间优先：抢占式调度，新作业到达时，调度程序总选择剩余时间最短的进程运行。
- 交互式系统：
  - 时间片轮转：每个进程被分配一个时间段，允许其运行，如果时间片结束，进程还在运行，则剥夺CPU给另一个进程。
    - 若时间片内进程阻塞或结束，CPU切换。
  - **优先级**调度：每个进程被赋予一个优先级，允许优先级最高的可运行进程运行。弊端是高优先级可能无休止运行，低优先级饿死。
    - 每个时钟滴答降低当前进程优先级+抢占式调度
    - 给进程赋予允许运行的最大时间片，然后次高优先级获得机会
  - 多级队列优先级：设立优先级类，类内轮转，最高优先级类分配一个时间片，次之两个，再次之四个。进程运行完后，优先级降低。
  - 最短进程优先、保证调度、彩票调度、公平分享调度
- 实时系统：
  - 硬实时的可调度：存在一个调度序列让每个进程都满足绝对截止时间。

## 5.页面置换算法

- FIFO、二次机会、工作集、时钟、LRU、NRU、老化算法、最优页面置换算法。

- 工作集：进程当前正在使用的页面集合（近似为：过去τ秒内访问过的页面）。
  - 每次时钟滴答检测访问位，R==1，设置上次使用时间为当前时间。R==0且生存时间大于τ，移出该页面
- 时钟：缺页中断时，R==1，置零，继续走。直到遇到R==0，替换。
- 工作集时钟：如果跑一圈都没有超出生存时间的，就替换脏页面。
- NRU：每次时钟滴答清零R位。 00 -> 01 -> 10 -> 11。
  - 认为替换一个没有访问的脏页面比替换一个频繁访问的干净页面更好。

## 6.电脑从开机到显示经历的步骤

- 从ROM中加载BIOS(Basic I/O System)，进行硬件自检。
- BIOS读入并执行磁盘0号扇区的MBR(Master Boot Record)。
- MBR确定活动分区，读入并执行该分区的引导块，引导块会装载该分区的操作系统。
- 控制权转交给操作系统后，操作系统的内核首先被载入内存。

## 7.DMA

- DMA以纯硬件的方式，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输，无需CPU的参与。

- DMAC与CPU的总线控制权交换方式：
  - **停止CPU方式**：CPU放弃了对总线的控制权，放弃了对主存的访问。
  - **周期挪用方式**：在常规程序运行中，CPU要花费很多时间执行内部CPU指令，在这些指令执行期间，CPU不需要总线的控制，也不访问内存。周期挪用方式利用CPU做內部操作或指令译码等未使用总线的时间，由DMAC迅速“窃取”一个总线周期的总线控制权，做一个数据的传输，然后立即将总线控制权交还给CPU。
  - **CPU与DMA交替分时工作**：把时间分成两个时间片，一片分给CPU，一片分给DMAC， 使CPU和DMAC交替地访问主存。

## 8.内存映射I/O和I/O端口空间

> 内存映射I/O

- 将所有的控制器寄存器映射到内存空间中，并分配唯一的一个内存地址。
- 工作时：CPU指出需要的地址 和 需要的是I/O还是内存空间，然后读取。

> I/O端口空间

- 每个寄存器被分配一个I/O端口，形成端口空间并受保护使普通用户不能访问，用特殊I/O指令将结果读入内存

>  内存映射I/O的优缺点

- 优点：
  - 内存映射I/O省去了读取寄存器到CPU的步骤
  - 不需要特殊的保护机制来组织用户进程进行I/O操作
  - 可以将不同的设备驱动程序放置在不同的地址空间里，防止相互干扰
  - 读I/O端口空间可能需要汇编语言，读内存空间只需要C语言
- 缺点：
  - 对设备的高速缓存可能导致数据不一致
  - 占用内存空间
  - 有了高速内存总线后，地址就不走总线了，I/O设备将无法查看内存地址

## 9.死锁？四个必要条件？如何预防？

- **死锁**：一个进程集合中 **每个进程都在等待只能由该集合中其他进程才能引发的事件**，那么该集合死锁。
- **死锁发生的四个必要条件**：
  - **互斥**：至少有一个资源必须处于非共享模式，即**一次只有一个进程可使用该资源**。如果另一进程申请该资源，那么申请进程应等到该资源释放为止。
  - **占有和等待**：—个进程应占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有。
  - **非抢占**：资源不能被抢占，即资源只能被进程在完成任务后自愿释放。
  - **环路等待**：有一组等待进程 {P0，P1，…，Pn}，P0 等待的资源为 P1 占有，P1 等待的资源为 P2 占有，……，Pn-1 等待的资源为 Pn 占有，Pn 等待的资源为 P0 占有。

- 记忆：资源非共享不可抢占，一个进程占一个等一个，形成环路。

> 检测并恢复死锁

- 检测死锁：dfs寻找资源分配图的有向图环路、资源向量图
- 从死锁中恢复：抢占、回滚、杀死进程

> 死锁避免

- 安全状态：没有死锁发生且即使所有进程突然请求对资源的最大需求也仍然存在某种调度次序能使每个进程运行完毕。
- 银行家算法：如果满足某个请求，系统是否仍能处于安全状态，如果是，则分配资源。否则，推迟满足该请求。

> 死锁预防

- 破坏互斥条件：假脱机打印机技术，避免资源被进程独占
  - 打印机守护进程会等到一个完整的输出文件就绪后才开始打印
- 破坏占有并等待条件：开始执行前请求所有资源
- 破坏不可抢占条件：虚拟化
  - 将计算机的各种实体资源（**CPU、内存、磁盘空间、网络适配器**等）予以抽象、转换后呈现出来并可供分割，组合为一个或多个电脑配置环境。
- 破坏环路等待条件：资源编号并顺序申请

## 10.饥饿

- 进程在某种资源调度策略下永远处于得不到服务的状态。尽管未被阻塞，但无限期地被推后执行。

## 11.多处理机系统

- 共享存储多处理机、消息传递多计算机、分布式系统

> 多处理机

- 访问存储器：UMA(uniform memory access)和NUMA：读取每个存储器字的速度是否一样快。

- OS类型：
  - 每个CPU共享OS代码，有自己的OS副本，各CPU运行自己的OS。
    - 各处理机状态相当独立，失去了多的意义
  - 主从多处理机：OS和数据表都在主CPU上，所有系统调用重定向至主CPU。
    - 单点故障
  - 对称多处理机：OS副本在存储器里，任何CPU都可以运行它
    - 多个CPU同时运行OS时，会出现灾难
- 调度策略：
  - 分时调度：为就绪线程维护一个系统级的数据结构，多CPU按优先级分时共享该数据结构
  - 空间共享：在多个CPU上同时调度多个线程
    - 一次性创建的线程，要么同时获得专用CPU，要么等待
  - 群调度：一个时间片内，一个进程的所有线程在不同CPU上同时运行

> 多计算机

- RPC：客户机本地调用客户机端存根，客机存根编排并发消息给服务器端存根，服务器存根调用服务器过程。应答则反向执行。

## 12.操作系统的特征

- 四个特征：并发、共享、虚拟、异步
- **并发** 和 **共享 **是操作系统的两个最基本的特征，他们互为存在的条件
- 共享：系统中的资源可以供内存中多个并发执行的进程共同使用
- 虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物
- 异步：也称不确定性，指进程的执行顺序和执行时间的不确定性

## 13.什么是内核

- OS的内部核心程序，是计算机功能的延伸。
- 主要包括：
  - 支撑功能：时钟管理、中断机制、原语。
  - 资源调度管理：进程管理、存储器管理等。
- 内核所处的地址空间叫内核空间，程序在内核空间的部分执行时所处的状态就叫内核态。
- 内核态=内核空间+内核权限。
- 内核以外的程序统称外部管理程序，用户态类似定义。

## 14.什么是文件

- 文件是进程创建的**信息逻辑单元**，是对磁盘的建模。它提供了一种在磁盘上保存信息并方便读取的方法。

## 15.软、硬链接

- 硬链接：多个文件名指向同一个inode，inode指向文件数据
- 软链接：链接文件包含文件的路径名

> 优缺点

- 硬链接优点：不会占用额外的 **inode**
- 硬链接缺点：无法**跨文件系统链接**、所有者**删除文件**数据将导致链接至无效或错误的inode
- 软链接优点：可以指向全球任何地方机器上的文件、创建新的视图和文件分类方式
- 软链接缺点：占用额外的inode、需要解析路径

## 16.文件分配方式

- 连续分配：起始地址+块数
  - 容易造成磁盘碎片化
- 链表分配：每个块的前几个字节存放指向下一块的指针
  - 随机访问慢
- FAT(file allocation table 文件分配表)：内存里的一个表，第i个表项代表磁盘第i块，表项内容为下一块的指针。
  - 表太大，占内存
- **inode**：每个文件的inode里存文件属性和文件块的磁盘地址

## 17.五种I/O模式

- 用户进程中的一个完整IO分为两阶段：用户进程空间<-->内核空间、内核空间<-->设备空间（磁盘、网络等）。
- IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。
- 对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。
  - 内核会为每个I/O设备维护一个缓冲区
- 5种IO模型分别是 **阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动的IO模型、异步IO模型**；
- 前4种为同步IO操作，只有异步IO模型是异步IO操作。
- **阻塞IO模型**：进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。
  - 因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。
- **非阻塞IO模型**：进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。
  - 进程轮询
- **IO复用模型（事件驱动IO）**：多个进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；如果select监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。
  - 专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式;
  - select、poll、epoll
- **信号驱动IO模型(SIGIO)**：当进程发起一个IO操作，会向内核注册一个**信号处理函数**，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。
- **异步IO**：当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。
  - 与信号驱动IO模式的区别：信号驱动IO由内核通知我们何时启动一个IO操作，异步IO由内核告诉我们IO操作何时完成。

## 18.动态链接和静态链接

- 静态链接是把所有用到的库文件都 **复制 **到目标模块中，形成可执行程序。
- 动态链接是在程序 **运行时才将库文件链接** 在一起形成一个完整的程序，每个模块都是独立的，不会复制。

## 19.大端字节序和小端字节序

- 大端序：高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。
- 小端序：低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。

## 20.块设备和字符设备的区别

- 磁盘是典型的块设备，支持随机读写，以块为单位进行读写。
- 字符设备，支持顺序读写，以字节/字符为单位进行读写。

## 100.补充的知识

> 高响应比优先调度算法

- 响应比：1+等待时间/处理时间

- 高响应比优先调度算法：FCFS算法忽略了程序运行时间，最短作业优先忽略了等待时间，高响应比算法权衡了两种算法的优点。

> 中断和异常的区别

- 中断又称外中断，指**CPU执行指令之外的事情发生**，如设备的I/O中断，时钟中断等。
- 异常又称内中断，指**源自CPU执行指令内部的事情**，如程序的非法操作码，**地址越界，算术溢出，缺页异常**等。异常处理一般要依赖当前程序运行的现场，不能被屏蔽。

> 将用户程序变为可在内存中执行的程序的步骤

- 编译：由编译程序将源码编译成若干目标模块
- 链接：由链接程序将编译好的一组目标模块和所需的库函数链接起来，形成完整的装入模块。
- 装入：由装入程序将装入模块装入内存中运行。

> 内存分配管理方式

- 固定分区分配：将用户内存空间分成若干个固定大小的区域，每个区域只装入一道作业。
- 动态分区分配：不预先划分内存，根据进程大小动态分配。
  - first fit、next fit、best fit、worst fit、quick fit

> Spooling（假脱机）技术

- 输入井、输出井：磁盘的两块存储空间，用于暂存输入、输出数据。
- 输入缓冲区、输出缓冲区：内存的两个缓冲取，用于缓冲CPU和磁盘的速度不匹配问题。输入设备传入的数据经由输入缓冲区送往输入井。输出的数据从输出井经由输出缓冲区送到输出设备。
- 输入进程和输出进程：把输入设备的数据经由输入缓冲区送到输入井，在CPU需要该数据时，再从输入井读到内存中。把输出的数据从输出井经由输出缓冲区送到输出设备。
- 特点：
  - 提高了I/O速度
  - 将独自设备改造为共享设备
  - 实现虚拟设备功能

> 操作系统功能

- 进程管理、内存管理、文件管理、输入输出管理、提供用户接口

>用户态线程和内核态线程的区别

- 内核态线程的I/O阻塞是线程级的，不会挂起进程。对用户态线程来说，内核阻塞进程，则该进程的所有线程都将被阻塞。

- 用户态线程可以使用专为应用程序定制的线程调度程序，可以提高性能。内核从不了解内核态线程。
- 用户态线程切换只需少量机器指令。内核态则需要完整的**上下文切换**，修改内存映像，失效高速缓存，代价很大。

> 处理机调度

- 高级调度：作业调度，将磁盘后备作业队列中的作业调入内存中，排在进程就绪队列中。
- 中级调度：内存调度，根据内存空间空闲情况，将进程从内存调出磁盘或从磁盘调入内存。
- 低级调度：进程调度，将进程状态由就绪调度为运行。

> 临界区和临界资源

- **临界资源**：一次只能供一个进程访问的资源
- **临界区**：进程访问临界资源的那段代码

> 进程上下文切换

- 挂起进程，保存进程状态；从就绪队列根据进程调度算法选择恰当进程；恢复该进程的状态；返回到上次执行的代码开始执行。
- 发生时刻：进程调度；中断处理；用户态切换到内核态执行内核程序



# 数据库

## 0.什么是数据库

- 数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。
- 数据库系统 包括 数据库 和 数据库管理系统
  - 数据库是 按一定数据结构存储数据的仓库。
  - 数据库管理系统是 操作和管理数据库的应用软件。
- 安全、一致、高效读写、持久化

## 1.数据库类型

> 关系型数据库

MySQL, SQL server

> 非关系型数据库（NoSQL）

**列存储：HBase**

**文档存储：MongoDB**

**key-value存储：Redis**

**图存储：Neo4J**

对象存储：db4o

xml数据库：BaseX

## 2.第一二三范式

- 第一范式：属性是原子不可分的

- 第二范式：非主属性**完全依赖**于主属性

- 第三范式：非主属性**不能传递依赖**于主属性

- BC范式：在三范式的基础上，消除 **主属性** 对于候选码的部分与传递函数依赖

## 3.各种码/键

- 码=超键：能够唯一标识一条记录的属性或属性集。
- 候选键=候选码：能够唯一标识一条记录的最小属性集
- 主键=主码：某个能够唯一标识一条记录的最小属性集（是从候选码里人为挑选的一条）
- 主属性：候选码所有属性的并集
- 外键：子数据表中出现的父数据表的主键，称为子数据表的外键。

## 4.数据库设计的三个步骤

- 概念设计：将用户需求抽象为E-R图。
- 逻辑设计：把基本E-R图转换为数据库系统支持的逻辑结构。
- 物理设计：为逻辑数据模型选取一个最适合应用要求的物理结构。

## 5.扇形陷阱和深坑陷阱

- 扇形陷阱(Fan Traps)：通常是产生于一些实体拥有**多个一对多的关联**，好像扇子散开一样，而关联在一起的实体间的关联性让人产生混淆。
- 深坑陷阱(Chasm Traps)：**实体间应该存在的关系却没有体现出来**，两个实体间并没有办法找到一条路径来连接。

## 6.数据依赖

- 数据依赖的主要类型：函数依赖、多值依赖、连接依赖。
- 函数依赖：设 R 为任一给定关系，如果**对于 R 中属性 X 的每一个值，R 中的属性 Y 只有唯一值与之对应**，则称 X 函数决定 Y 或称 Y 函数依赖于 X。X -> Y。
  - 平凡函数依赖：X -> Y，且X包含Y。
- 多值依赖：关系R，属性集X、Y、Z 满足 R - X - Y = Z。X - -> Y 的意思是 X与Y之间的联系独立于 X与Z之间的联系。

## 7.事务的ACID

- 原子性(atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。
- 一致性(consistency)：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。

- 持久性(durability)：一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。
- 隔离性(isolation)：多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

>不进行隔离可能面临的问题

- 数据丢失：两个更新事务同时修改一条数据时，会造成数据修改的丢失。

- 脏读：一个事务范围内读取了另一个未提交的事务中的数据。
  - 因为事务可能回滚，这就导致读到的数据可能不存在。
- 不可重复读：一个事务范围内多次查询却返回了不同的数据值（针对的是更新）。
- 幻影读：事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中再次查询，会发现好像刚刚的更改对于某些数据未起作用（针对的是数据的插入）。

> 事务隔离级别

- 事务的隔离级别按照从弱到强分别为：Read Uncommitted (未提交读)，Read Committed（提交读），Repeatable Read（可重复读）和Serializable（串行化）。
- **读未提交**：事务A可以读取事务B未提交的数据。
- **读已提交**：事务A只能读取事务B修改并且提交后的数据，可以避免脏读。
- **可重复读**：事务A在读取数据行时，禁止其他事务对该数据行进行更改，但是可以进行读取操作。进行写操作时，禁止其他事务的任何操作。可以避免脏读和不可重复读。
- **串行化**：事务执行结果和某种串行执行的结果相同，可以避免脏读、不可重复读和幻影读。

## 8.两阶段锁

- 事务分两个阶段，第一个阶段是获得锁。事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是释放锁 ，事务可以释放任何数据项上的任何类型的锁，但不能申请。

# 编译原理

## 0.编译的步骤

- 词法分析：识别记号并分类；
- 语法分析：识别语言结构，并以 树 的形式表示；
- 语义分析：考察结构正确的句子是否语义合法、修改树结构、查填符号表；
- 中间代码生成：生成一种既接近目标语言，又与具体机器无关的表示，便于优化与代码生成。
- 代码优化
- 目标代码生成

***

- 填查符号表、出错管理

## 1.编译程序和解释程序

- 编译：将高级语言转化为可执行程序，翻译和执行过程是分离的。
  - 程序控制权在用户手中
  - 一次编译，多次执行，工作效率高
  - 可移植性差
- 解释：将高级语言**逐句解释并执行**，翻译和执行过程是一起进行的。
  - 程序控制权在解释器手中
  - 每次执行都需要重新翻译，工作效率低
  - 可移植性强

## 2.词法分析

- **词法分析**：正规式、有限自动机(NFA、DFA)

- 正规式：有限字母表上的正规式是递归定义的。ε、r、s、r|s、rs、(rs)、r*。并集、连接、闭包
- NFA(Nondeterministic Finite Automaton)：非确定有限自动机，五元组（初态、终态集、有限状态、有限字符、状态转移函数）。
- DFA(Deterministic Finite Automaton)：确定有限自动机，是NFA的一种特例。
- NFA和DFA的区别：对于DFA的每个状态，一个输入字符，最多有一个下一状态，且无空转移。

- 构造词法分析器的步骤：用正规式描述模式、正规式->NFA(Thompson算法)、从NFA构造DFA（子集法）、最小化DFA、从DFA构造词法分析器（模拟DFA）

## 3.语法分析

- **语法分析**：上下文无关文法（2型文法，子集：LL文法、LR文法）、自上而下分析、自下而上分析、下推自动机。
- CFG(Context Free Grammar)：上下文无关文法，四元组（开始符号、非终结符、终结符、产生式）。
  - 反复使用产生式得到终结符序列
- 句型：开始符号至少一步推导产生的序列。
- 句子：序列中只有终结符。
- 最左推导：每次直接推导均替换句型中最左边的非终结符。
  - 最右推导是规范推导。
  - 最左规约是规范规约，是最右推导的逆过程。
- 自上而下分析：从S开始进行最左推导，直到得到一个合法的句子或发现一个非法结构。
- 自下而上分析：从输入序列开始,反复用产生式的左部替换产生式的右部、谋求对系列的匹配,最终得到文法的开始符号，或者发现一个错误。
- 左递归：A=>Aa
- 提取左因子：当不确定用A产生式的哪个候选项替换A时，可以重写A的产生式来推迟这种决定，直到看见足够的输入，能正确决定所需选择为止。
- 下推自动机：用来实现上下文无关文法的机器。在有限状态机的基础上，多一个栈。**状态转移时，不仅考虑有限状态部分，还要参照当前栈的状态**。
- 预测分析表的构造：
  - 对FIRST(α)的每个终结符a，加入α到M[A，a]；
  - 若ε∈FIRST(α)，则对FOLLOW(A)的每个终结符b(包括#)，加入α到M[A，b]。
- 原因：
  - 若当前栈顶为A，当前输入为a，则规则2表示下一步动作是展开A→α。因为a∈FIRST(α)，所以展开后下一次正好匹配a。
  - 若当前栈顶为A，当前输入为b 且b∈FOLLOW(A)，则下一步动作是展开A→ε，即栈顶弹出A，继续分析A之后的部分。因为b∈FOLLOW(A)，所以弹出A后下一次正好匹配A的后继b。
- 短语：S=>αAδ(推导)，A=>β(至少一步推导)，则称β是句型αβδ相对于A的短语。
  - S可以推导出A，A至少一步推导出β

  - 以非终结符为根子树中所有从左到右的叶子

- 直接短语：A -> β ,一步推导。
  - 只有父子关系的子树中所有从左到右排列的叶子（树高为2）

- 句柄：最左直接短语。
  - 最左边父子关系树中所有从左到右排列的叶子

- 最左规约：每次都将输入序列的句柄替换为产生式左部的非终结符。
- 移进-规约分析表：保证栈中总是活前缀（指导移进）、确定栈顶的句柄并用正确的产生式进行规约（指导规约）。

- LR(k)语言：L 表示从左到右扫描输入序列，R 表示逆序的最右推导，k 表示为确定下一动作向前看的终结符个数。

- SLR(1)文法：通过简单向前看1个输入符号的方法来解决LR(0)文法面临的冲突问题。


>记忆

- 本章最重要的概念：自上而下和自下而上语法分析、上下文无关文法和实现CFG的下推自动机。
- 自上而下叫推导，是从开始符号不断替换句型中最左非终结符，直到得到合法句子或错误的过程，用的是预测分析表。
- 自下而上叫规约，是将输入序列句柄不断替换为非终结符，直到得到开始符号的过程，用的是移进-规约分析表。

## 4.语义分析

- **语义分析**：语法制导翻译
- 语法制导翻译：伴随语法分析的各个步骤，执行相应的语义动作。
  - 用**属性**表示对应文法符号的含义
  - 用**语义规则**实现语义计算
  - 在适当时刻**执行**附着在产生式上的语义规则。
- 综合属性：A->a，b := f(c1,c2, ...ck)，b是A的属性，c1, c2, ..., ck是α中文法符号的属性，或者A的其它属性，则称b是A的综合属性。
- 继承属性：若b是α中某文法符号Xi的属性，c1, c2, ..., ck是A的属性，或者是α中其它文法符号的属性，则称b是Xi的继承属性。

- 中间代码的三种形式：后缀式、树、三地址码。

# 计算机组成

## 0.计算机体系结构和组成的区别

- 体系结构是底层程序员能看到的机器属性，包括指令集、数据类型、存储器寻址等技术。
- 组成是实现体系结构的硬件细节，如指令系统如何取指、分析指令、取操作数、运算等。

## 1.冯·诺依曼机的结构

- 输入设备，输出设备，存储器，控制器，运算器

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\冯·诺依曼结构.webp)

- 运算器的主要部件就是算术逻辑单元（Arithmetic Logic Unit  ALU），进行算术运算和逻辑运算。
- 控制器的工作流程为：从内存中取指令、翻译指令、分析指令，然后根据指令的内存向有关部件发送控制命令，控制相关部件执行指令所包含的操作。
  - 控制器和运算器共同组成中央处理器（Central Processing Unit），CPU是一块超大规模集成电路，是计算机运算核心和控制核心，CPU的主要功能是解释计算机指令以及处理数据。

- 存储器：在冯诺依曼结构里，**存储器主要指的是内存**。

- 输入设备：向计算机输入数据和信息的设备。包括键盘，鼠标，摄像头，网卡和硬盘等等(网卡是因为从网络接收数据相当于输入设备，硬盘往硬盘写东西，硬盘相当于输入设备)

- 输出设备：是计算机的终端，用于接收计算机发出的数据信息。包括显示器，声卡，网卡，硬盘。(网卡是因为通过网卡发送数据到网络上，硬盘从硬盘上读取文件)


> 与哈佛体系结构的区别

- 哈佛结构是一种将**程序指令存储**和**数据存储**分开的存储器结构；冯诺依曼结构的程序和数据共用一个存储器。

> 指令包括操作码和地址码，操作码表示操作的性质，地址码表示操作数的存储位置

> 冯机以运算器为中心，现代计算机以存储器为核心，CPU只有内存交换数据

## 2.各种周期

- **时钟周期**：是计算机中最基本的、最小的时间单位，是完成一个微操作需要的时间。是时钟频率的倒数。
- **总线周期**：通常把CPU通过总线对处理器外部（存储器或 I/O接口）进行一次访问所需时间称为一个总线周期。一个总线周期一般包含4个时钟周期，这4个时钟周期分别称4个状态即T1状态、T2状态、T3状态和 T4状态。
- **CPU周期**：也称机器周期。是CPU访问一次内存花的时间。指令周期常常用若干个CPU周期数来表示。
- **指令周期**：取出并执行一条指令的时间。
  - 各种指令的指令周期是不尽相同的。
- 关系：**一个指令周期由若干个CPU周期组成**，**一个 CPU 周期包含多个时钟周期**，**一个总线周期包含有若干个时钟周期**。

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\计组_各种周期.png" style="zoom: 50%;" />

## 3.cpu 一个指令周期的流程是什么？

- **五个阶段**：取指令、指令译码、取操作数、执行指令、结果写回。

## 4.衡量计算机性能的指标

- 主存容量
- CPU
  - 主频：机器内部主时钟的频率
  - MIPS（Million Intructions Per Second）每秒CPU能执行多少条指令(以百万为单位）
  - FLOPS（Floating-point Operations Per Second）每秒执行浮点运算次数 
  - CPI（Clock cycle Per Instruction）执行一条指令所需的时钟周期数
- 带宽：CPU外部数据总线宽度。
- 吞吐：单位时间处理任务的数量，与CPU处理速度和主存的存取速度有关。
- 响应时间：用户从发送请求到获得结果的时间间隔。包括CPU时间和等待时间。
- 字长：计算机一次整数计算所能处理的二进制位数。

## 5.计算机按指令和数据流划分

- SISD单指令流单数据流：冯·诺依曼体系结构
- SIMD单指令流多数据流：阵列处理器和向量处理器
- MISD多指令流单数据流：这种计算机不存在
- MIMD多指令流多数据流：多处理器和多计算机

## 6.为什么用二进制编码？

- 恰好对应逻辑真、假，便于逻辑运算
- 二进制的表示和计算都很简单
- 只有两个状态，能用有两个稳定状态的物理器件简单表示，成本低。

> 计算机存储数据存的是补码

## 7.Cache

- 时空局部性原理
- Intel core i7：三级缓存，L1、L2缓存在CPU核内部独有，L1分D-cache（数据） 和 I-cache（指令）。多核共享L3 cache。

> 主存到Cache的地址映射

- 全相联：**主存中的任意块均可以装入Cache中的任意一个块。**
- 直接相联：**主存中的任意块只能装入Cache中的固定一个块。**
  - 内存分区， 区的大小和cache的大小对应，cache内的第i块，对应每个内存区的第i块
- 组相联：**组间直接、组内全相联。**
  - 内存分区，区内分组，cache也分组。内存某区第i组只能映射到cache第i组，但组内可以随便映射。

> 块替换算法

- 随机替换
- 先进先出
- LRU：有点复杂。。。。。。（摆）
- LFU（最不经常使用算法）：每访问一次，cache行计数器+1，替换计数值最小的行。

> 写策略

- 写回法（write back）：只写cache，不写主存。
- 写直达（write through）：写cache时，也写主存。

> cache块大点、小点怎么说

- 从命中率角度：cache块小，局部性不容易发挥。cache块大，块数少，也不易命中。
- 从空间利用率角度：cache块小，剩余空间少，页表大。cache块大，剩余空间多，页表小。

## 8.存储器

> 按存取方式分类

- RAM：随机存取、断电即失、常用于主存和高速缓存。
- ROM：持久化存储、写入比读取慢很多、广义的ROM也是随机存取。
- 串行访问存储器：顺序存取存储器（磁带）和直接存取存储器（磁盘）。

> 性能指标

- 存储容量
- 单位成本
- 存储速度：数据传输率 = 数据宽度/存储周期
  - 存取时间+恢复时间=存取周期
  - 数据传输率又称主存带宽

## 9.SRAM和DRAM

- SRAM静态随机存储器，触发器存储，无需刷新，常用于cache。

- DRAM动态随机存储器，电容存储，需要刷新，常用于主存。
  - DRAM成本低于SRAM，速度也慢于SRAM。


## 10.**Cache-主存**和**主存-辅存**两个存储层次的比较

> 不同点

- 解决的问题不同。前者为了解决CPU和内存速度不匹配的问题，后者为了解决存储容量不足的问题
- 透明性不同。cache的管理完全由硬件完成,对系统程序和应用程序均透明。而虚存管理由操作系统和硬件共同完成,对系统程序不透明,对应用程序透明(段式和段页式管理对应用程序“半透明”)。
- 未命中时的损失不同。由于主存的存取时间是 cache 的5~10倍,而辅存的存取时间通常是主存的上千倍。所以虚拟内存未命中的损失远高于cache未命中。
- CPU与cache、CPU与主存间有直接的数据通路，cache不命中可以直接访问主存。但辅存和CPU间无直接通路，只能通过页面置换来访问。

> 相同点

- 都是利用程序局部性原则
- 都为了提高系统性能
- 都划分为小信息快
- 都有地址映射、替换算法、更新策略

## 11.RISC和CISC

- RISC(reduced instruction system computer)：指令数少、指令长度及格式固定的、只有load/store能访存、硬布线控制器，指令流水线、寻址方式简单，大多数为寄存器直接寻址
- CISC(complex instruction system computer)：指令数多、指令长度和格式不固定、不限制访存指令、微程序控制器、寻址方式复杂

## 12.硬布线控制器和微程序控制器

- 硬布线控制器：又称组合逻辑控制器，是将控制部件做成产生专门固定 **时序控制** 信号的逻辑电路，产生各种控制信号。微操作控制信号**由组合逻辑电路根据当前的指令码、状态和时序，即时产生**。
- 微程序控制器：事先把每一条机器指令编写成一个微程序，然后**把这些微操作控制信号存储在控制存储器**中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。

## 13.指令流水线

- 流水线技术：将一重复的处理过程分解为若干子过程，每个子过程都可有效地在其专用功能段上与其它子过程同时执行。
- 相关：相近指令因存在某种关联，使后一条指令不能在原定的时钟周期开始执行。
  - 结构相关：硬件资源冲突
    - 所有功能单元完全流水化、设置足够多的硬件资源
  - 数据相关：一条指令需要用到前面指令的结果，无法与产生结果的指令重叠执行
    - 通过直通技术、流水线互锁硬件、编译器等插入暂停周期
  - 控制相关：流水线遇到分支指令和其它会改变PC值的指令
    - 预期分支目标、循环缓冲器、延迟分支、冻结流水线
- **多指令流出处理器**：超标量、超流水、超长指令字
  - 超标量：每个时钟周期可并发多条独立指令，多条指令并行编译执行。
  - 超流水：一个时钟周期再分段，在一个时钟周期内一个功能部件使用多次。
  - 超长指令字：将多条能并行操作的指令组成一条具有多个操作码字段的超长指令字。


## 14.总线

- 总线是一组能为多个部件**分时** **共享**的公共信息传送线路。

> 功能划分

- 片内总线：CPU芯片内部的总线，连接寄存器、ALU间的连接线。
- 系统总线：系统各功能部件（CPU、I/O设备、主存）间相互连接的总线
  - 数据总线、控制总线、地址总线
- 通信总线：计算机与其他系统相连的总线，又称外部总线

>总线结构

- 单总线：CPU、内存、I/O设备都在一组总线上。
- 双总线：I/O设备挂在I/O总线上，通过通道技术，与CPU、内存一同连接在主存总线上。
- 三总线：主存总线（CPU、主存间）、DMA总线（主存、IO设备间）、I/O总线（CPU、IO设备间）。

> 总线仲裁方式

- 集中仲裁：将总线请求集中起来仲裁
  - 链式查询：离总线控制器越近，优先级越高。
  - 计数器定时查询：设备号与计数值相同的设备获得总线，计数值可以固定从0开始，也可以从上次终点开始或者程序控制。
  - 独立请求：要用总线的，到总线控制器那儿排队，获批的会收到响应。
- 分布仲裁：通过仲裁总线广播各自的仲裁号，号最大的设备获得总线。

## 15.四种I/O类型

- 程序直接控制：CPU全程参与I/O操作
  - 无条件传输：CPU直接与外设进行输入输出操作
  - 查询方式：CPU通过指令询问外设的工作状态,然后根据外设的状态确定对其进行I/O操作的时刻
- 中断方式：CPU启动IO工作，然后继续原来的程序，等外设传输数据完毕，主动向CPU发出中断请求，CPU在中断服务程序中完成IO操作。
- DMA方式：在DMAC的控制下，以纯硬件的方式完成IO操作。
- 通道方式：

## 16.中断

> 中断的概念

- 某件事情的发生引起CPU暂停当前程序的运行，转入对所发生事情的处理，处理结束后又回到原程序被打断处接着执行的过程。

> 中断的作用

- 实现CPU和IO设备并行工作
- 处理硬件故障和软件错误
- 用户干预机器需要用到中断，实现人机交互
- 实现多道程序、分时操作

>中断分类

- 外中断、内中断
- 硬件中断、软件中断：硬件产生的中断、指令产生的中断
- 可屏蔽中断、非可屏蔽中断：均是外中断、关中断可响应和关中断不可响应

> 中断响应条件

- 有中断请求
- 开中断
- 一条指令执行结束，且无更紧迫事务

> 中断保护

- PSW、CS、IP **压栈** （CPU硬件自动完成）
- 其它寄存器(AX、BX … ) **压栈** （ISR完成 interrupt service routine）

> 允许中断嵌套的ISR

- 断点保护和断点恢复时需要关中断
- 关中断——断点保护——开中断——中断服务——关中断——断点恢复——开中断——断点返回

## 17.DMA(Direct Memory Access)

> DMAC和CPU的总线控制权交换方式

- 停止CPU方式：
- 周期挪用方式：利用CPU做內部操作或指令译码等未使用总线的时间，由DMAC迅速“窃取”一个总线周期的总线控制权，做一个数据的传输，然后立即将总线控制权交还给CPU。
- 交替分时工作：把时间分成两个时间片，一片分给CPU，一片分给DMAC，使CPU和DMAC交替地访问主存。

> DMA和中断的区别

|        区别        |      中断       |          DMA          |
| :----------------: | :-------------: | :-------------------: |
|      响应时间      |  指令周期结束   |      CPU周期结束      |
|      请求对象      |   程序控制权    |      总线使用权       |
|      CPU作用       |  全程参与控制   | 仅参与DMA的启动和结束 |
|       优先级       |       低        |          高           |
| 外设与主存连接方式 |    需经过CPU    |   数据通路直接连接    |
|      现场保护      | 需要保护CPU现场 |     不会改变现场      |

## 18.通道

- 用于控制I/O设备与内存之间的数据传输。启动后可独立于CPU运行，实现CPU与IO并行。
- 根据数据传送方式，通道可分成字节多路通道、选择通道和数组多路通道三种类型。

## 102.段式、页式、段页式

> 页式

- 将各进程的虚拟空间划分为若干个长度相等的页，然后把页式虚拟地址与内存地址建立一一对应的页表。
  - 优点：没有外碎片，每个内碎片不超过页的大小。
  - 缺点：程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。

> 段式

- 把程序按逻辑结构分成段，每段有自己的名字。段式管理程序以段为单位分配内存，然后通过地址映射机制把段式虚拟地址转换为实际内存物理地址。
  - 优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。
  - 缺点：会产生碎片。

> 段页式

- 进程地址空间首先被分成若干逻辑段，每段都有自己的名字，然后再将每一段划分成若干大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位。



# 计算机网络

## 1.什么是计算机网络

- 利用**通信设备**和线路将地理位置不同的、**功能独立的多个计算机系统连接起来**，以功能完善的网络软件实现网络的硬件、软件及**资源共享和信息传递**的系统。
- 简单的说：连接两台或多台计算机进行通信的系统。

## 2.网络协议

- 网络协议：为进行网络中的数据交换而建立的规则，规定了通信的**内容**、通信**方式**和通信的**时间**。
- 协议由语法、语义和时序三部分构成。
  - 语法(syntax)，数据的结构或格式
  - 语义(semantics)，地址和控制信息
  - 时序(timing)，报文发送的时间和发送的速率。

## 3.OSI（开放系统互联）模型

- 7层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
- **物理层**：负责 **位** 从一 **跳** 到另一 **跳** 的传递。
  - 数据速率、拓扑结构、传输方式
- **数据链路层**：负责 **帧** 从一 **跳** 到下一 **跳** 传递。
  - 成帧、物理寻址、流量控制、差错控制、访问控制
- **网络层**：负责将各个 **分组** 从 **源地址** 传递到 **目的地址** 。
  - 逻辑寻址、路由选择

- **传输层**：负责一个 **报文** 从一个 **进程** 到另一个 **进程** 的传递。
  - 端到端的可靠传输、分段Segment和组装、连接控制、流量控制、差错控制
- **会话层**：负责对话控制和同步。
- **表示层**：负责翻译、加密和压缩数据。
- **应用层**：向用户**提供服务**。

![](C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\计网_OSI模型协议.png)

> 可靠服务

- 可靠服务指网络具有检错、纠错、应答、重传等机制

>数据链路层和传输层的差错控制的区别

- 数据链路层的差错控制保证物理链路是“无比特错误”的，但不考虑“帧丢失”，“帧重复”和“帧失序”。由传输层的可靠传输考虑这些问题。
- 数据链路层的差错控制靠的是成帧和冗余检验、自动重传请求。传输层的可靠传输靠的是面向连接机制。

> 数据链路层和传输层的流量控制的区别

- TCP的滑动窗口是面向字节的，数据链路层的滑动窗口是面向帧的；
- TCP的滑动窗口是可变大小的，而数据链路层的滑动窗口是固定大小。

## 4.奈奎斯特定理与香农定理

- **奈奎斯特定理**：无噪声信道最大传输速率
  - 比特率 = 2 × 带宽 ×  log~2~L，  L是电平数

- **香农定理**：有噪声信道最大传输速率
  - 通道容量 = 带宽 × log~2~(1 + SNR)，SNR为信噪比

## 5.数据链路层的差错控制：检错、纠错码

- 奇偶校验码、汉明码、循环冗余校验码
- **奇偶校验码**：通过增加冗余位使得码字中"1"的个数恒为奇数或偶数的编码方法。在实际使用时又可分为垂直奇偶校验、水平奇偶校验和水平垂直奇偶校验等几种。
  - 简单奇偶校验码能检出奇数个差错
  - 两维奇偶校验能检测出所有3位或3位以下的错误、奇数位错以及很大一部分偶数位错。
- **汉明码**：
  - 汉明码如果要检测出D位错误，需要一个码距为D+1的编码方案，如果要纠正D位错误，那么需要一个码距为2D+1的编码方案
  - **2^r^ ≥ k+r+1 （其中r代表校验个数）**

- **循环冗余校验码**：对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。
  - k 位数据字，n 位码字，数据字右边加上 n - k 位 0，变成 n 位后传给生成器；
  - 生成器用长度为 n – k +1的除数（生成多项式）去除增加长度后的数据字（模 2 除法）；
  - 除法的商被丢弃，余数加到数据字上生成码字。校验器用相同的除数去除码字，得到的余数是n - k位校正子；
  - 如果校正子全0，码字最左边k位被接收为数据字，否则丢弃

## 6.数据链路层的可靠传输（滑动窗口协议）

> 数据链路层分为 逻辑链路控制子层LLC 和介质访问控制子层MAC

- 数据链路层的可靠传输通常使用确认和超时重传两种机制来完成。
- 停止等待ARQ(Auto Repeat reQuest)、回退N帧ARQ、选择重传ARQ 
- **停止等待ARQ**：发送窗口和接收窗口都是1，超时未收到ACK，则自动重传该帧
  - 不论是发送帧丢失、损坏，还是ACK丢失，接收方都不干活，发送方自动重传

- **回退N帧ARQ**：发送窗口为2^m^-1，接受窗口为1，超时未收到ACK，自动重传待处理的所有帧
  - m是序列号字段长度。为了确保发送窗口和接受窗口的序号没有重叠。

- **选择重传ARQ**：发送窗口和接受窗口都为2^m-1^，接收方通过NAK要求发送发重传某帧。

## 7.复用

- 频分多路复用：将信道资源按频率进行划分，分成一个个频带的子信道，让每个信号只去用其中的某一个频带的子信道

- 波分多路复用：合并多个光信号的模拟多路复用技术，就是光的频分多路复用。

- 时分多路复用：组合多个低速通道为一个高速通道数据的复用技术；它允许多个连接共享一条高带宽链路，每个连接占用链路的一个时间片段。
  - 同步时分多路复用：每一个用户在每一个TDM帧中占用固定序号的时间片
  - 统计时分多路复用：各用户有了数据就随时发往集中器的输入缓存，不会将时隙固定的分配给某个用户。每个时隙中必须要有用户的地址信息

## 8.随机访问协议

> 通过非集中式的协议争用信道，胜者发！

- 纯ALOHA：随时想发随时发，超时未收到ACK，就说明冲突了，等待一段时间后重发。

- 时隙ALOHA：时隙开始时发一个帧。
- 载波侦听多路访问(CSMA)：时隙ALOHA的基础上，站点发送前侦听一下共用信道，避免冲突。
  - 1-坚持：信道忙，则坚持侦听；信道闲，1的概率，发送帧
  - p-坚持：信道忙，则坚持侦听；信道闲，p的概率，发送帧，1-p的概率，在下一时隙重新进行前述步骤。
  - 非坚持：信道闲，发送帧；信道忙，放弃侦听，等待随机时间再重新进行前述步骤。
- 带冲突检测的载波侦听多路访问(CSMA/CD)：CSMA基础上，如果发送过程中检测到冲突，则停止发送，等待随机时间后再次发送。
  - 争用期：两倍传播时间 内没有检测到冲突，才能确定没有冲突。
  - 二进制指数退避算法确定等待时间
  - 有线局域网：通过电缆电压检测冲突。
  - 只能检测冲突，无法避免。
  - 无ACK机制

- 带冲突避免的载波侦听多路访问(CSMA/CA)：信道闲时，等待一个帧间间隔，然后进入竞争窗口，才能发送帧。
  - 帧间间隔用来实现发送优先级、竞争窗口用来避免冲突。
  - 无线局域网：因为冲突检测难、隐蔽站问题，采用能量检测和载波检测~~冲突。
  - 只能尽量避免冲突，无法检测到接收处是否冲突。
  - 有ACK机制

## 9.局域网

- 局域网：较小的地理范围内（学校），将各种计算机、外设等通过双绞线、同轴电缆等介质连接互联起来，形成信息传递、资源共享的网络。
- 有线局域网（802.3）：约等于 **以太网**。
  - 常见拓扑结构：总线、星形、环形、总线和星形。
  - 介质：同轴电缆、双绞线、光纤。
  - 发展：10Mbps、100M、1G、10G。
- 无线局域网（802.11）

## 10.广域网

- 广域网：覆盖范围很广（远超一个城市）的长距离网络。
- 广域网的数据链路控制协议：HDLC（面向比特）、PPP（面向字节）。

## 11.IPv4

- IPv4：逻辑地址、32bit、唯一定义了一个连接在因特网上的设备。
- 分类IP地址：A、B、C、D、E。
- 子网划分：网络号的若干位划分为子网号，利用子网掩码可以找到子网号。
- 构成超网

- 无分类编址CIDR：网络前缀+主机号，掩码用"/"隔开。
- 专用地址（私有地址）：只用于机构内部的地址。
- IPv6：128bit、无类编址、NAT

## 12.NAT(Network Address Translation)

- 私有网络中的多台主机只通过少量共有IP访问Internet。

- 静态NAT（Static NAT）实现了私有地址和全球公有地址的一对一映射，一个公有IP地址只会分配给唯一且固定的内网主机。
- 动态NAT（Dynamic NAT）是指将内部网络的私有IP地址转换为公有IP地址时，IP地址对是不确定的、随机的，所有被授权访问Internet的私有IP地址可随机转换为任何指定的公有IP地址。当ISP提供的公有IP地址略少于网络内部的计算机数量时，可以采用动态转换的方式。
- 网络地址端口转换PAT（Port Address Translation）是把内部地址映射到外部网络的一个IP地址的不同端口上。PAT与动态地址NAT不同，它将内部连接全部映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的端口号。

## 13.ARP(Address Resolution Protocol)

- ARP：逻辑地址到物理地址的映射

> 动态解析流程

- 发送方广播ARP请求报文（包括：接收方的逻辑地址、自己的逻辑和物理地址）
- 接收方单播ARP回答报文（将物理地址发送给发送方）

> RARP(Reversed Address Resolutoin Protocol)

- RARP：物理地址到逻辑地址的映射

## 14.DHCP(Dynamic Host Configuration Protocol)

- 局域网由物理地址获取逻辑地址的协议。
  - 应用层协议，基于UDP。

- 由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。

> 流程

- 【DHCP DISCOVER】**寻找服务器**：当 DHCP客户端首次登录网络的时候，如果发现本机上没有任何IP配置，则会向网络发出一个 DHCPDiscover广播，源地址为 0.0.0.0 ，目的地址则为 255.255.255.255。
- 【DHCP OFFER】**分配IP地址**：当DHCP服务器监听到客户端发出的 DHCP Discover 广播后，它会从那些还没有租出的地址范围内，选择最前面的空置IP，连同其它TCP/IP设定，发给客户端一个DHCP Offer，DHCP Offer会包含一个租约期限的信息。
- 【DHCP REQUEST】**请求使用**：如果客户端收到网络上多台DHCP协议服务器的响应，只会挑选其中一个 DHCP Offer ，并向网络发送一个DHCP Request广播，告诉所有 DHCP服务器它将指定接受哪一台服务器提供的IP地址。同时，客户端还会向网络发送一个 ARP ，查询网络上面有没有其它机器使用该IP地址；如果发现该IP已经被占用，客户端则会送出一个 DHCP Decline 给 DHCP服务器，拒绝接受其 DHCP Offer ，并重新发送 DHCP Discover 信息。
- 【DHCP ACK】**IP地址分配确认**：当DHCP服务器收到DHCP客户机回答的DHCP Request请求信息之后， 它便向DHCP客户机发送一个包含它所提供的IP地址和其他设置的DHCP ACK确认信息，确认IP地址的正式生效。然后DHCP客户机便将其TCP/IP协议与网卡绑定。除DHCP客户机选中的服务器外，其它的DHCP服务器都将收回曾提供的IP地址。

## 15.ICMP(Internet Control Message Protocol)

- ICMP（因特网控制报文协议）：配合IP协议使用，弥补IP协议没有差错报告、主机和管理查询等功能的缺点。
  - 差错报告报文和查询报文
- 差错报文：当差错发生时，向源端发送差错报告报文。截断IP分组，添加ICMP首部，并作为差错IP报文的数据部分，回发。
  - 源端抑制、目的端不可达、超时、参数问题、重定向
- 查询报文
  - 回送请求和回答：诊断网络 
  - 时间戳请求和回答：确定数据报的往返时间，同步 
  - 地址掩码请求和回答：获取地址对应的掩码 
  - 路由器询问和通告：询问路由器是否可正常工作

## 16.单播路由选择协议

- 路由选择协议：是一些规则和过程的组合，使得在互联网中的各路由器能够彼此互相通知路由表的变化。
- 路由器将分组发给哪个网络取决于可用路径是否最佳。
- 域内路由协议：RIP（距离向量/路由信息协议）和OSPF（链路状态/开放最短路径优先）
  - RIP(Routing Information Protocol)：固定时间间隔，通过与邻站共享路由表来更新距离向量，选择距离（跳数）最小的路径转发分组。
    - 因为每个路由器记录了到其他所有路由器的距离，最大距离不超15，所以只适用于小型网络
    - 是应用层协议，传输层用UDP发送
  - OSPF(Open Shortest Path First)：链路状态发生变化后，通过向自治系统内所有路由器洪泛自己的链路状态，代价可以灵活变化。
    - 是网络层协议，直接用IP数据报发送
- 域间路由协议：BGP（路径向量/边界网关协议）
  - BGP(Border Gateway Protocol)：当BGP路由表发生改变时，BGP发言人向其他域的BGP路由器发送路由表。
    - 寻求一条能到达且较好的路由（不兜圈子）
    - 路由表内容：目的网络前缀、路径序列、下一跳路由器
    - 是应用层协议，传输层用TCP发送


## 17.TCP

- TCP(Transmission Control Protocol/传输控制协议)：
  - 面向连接、差错控制、流量控制、拥塞控制、面向字节流、一对一、全双工

> 三次握手的原因

- **为什么不是两次握手**：第三次握手是**为了防止失效的连接请求到达服务器，让服务器错误打开连接。**客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

> 四次握手释放连接

- 就是把三次握手的第二次，ACK和FIN拆成两次发。ACK和FIN间，服务器可以向客户端发送数据，反之不行。
- ACK+FIN --> ACK --> ACK+FIN -->ACK

> 流量控制

- TCP的流量控制由滑动窗口来实现的，滑动窗口控制流量取决于接收方的窗口大小。
- TCP窗口受接收方窗口（rwnd）和拥塞窗口（cwnd）大小的影响，取两者中的最小值；
- 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。
- 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。
- 接收窗口只会对窗口内最后一个按序到达的字节进行确认。

> 拥塞控制

- TCP检错、纠错的三种方法：校验和、确认和超时重传。 
- 拥塞控制的报文传输单位是MSS（Maximum Segment Size）
- 慢启动（指数增加）：拥塞窗口以指数增长
  - 慢启动阈值：指数增长的阈值，达到该阈值后进入加性增加阶段。
- 拥塞避免（加性增加）：每次增加1。
- 拥塞检测（乘性减少）：阈值设为当前拥塞窗口的一半。如果是超时，cwnd为1,进入慢启动阶段。如果是三个重复ACK，cwnd为阈值大小，进入拥塞避免阶段。
- 快速恢复：三个重复ACK后的策略就是快速恢复。

> 快重传

- 要求接收方每收到一个失序的报文段后就立即发出重复确认。
- 当发送方收到3个重复的ACK时，直接重传该报文段，不必等该报文段的重传计时器超时。

## 18.UDP

- UDP(user datagram protocol/用户数据报)：
  - 无连接、不可靠、无差错控制、无流量控制、无拥塞控制、简单、开销小
  - UDP数据报 + IP首部 = IP数据报

## 19.TCP和UDP的选择

- UDP适合实时、无需分段的数据传输
  - QQ语音
  - RIP协议
- TCP适合多次交互、需要分段、有通讯质量要求的数据传输
  - HTTP、HTTPS、FTP等传输文件的协议
  - POP、SMTP等邮件传输的协议

## 20.DNS？递归查询和迭代查询？

- DNS(Domain Name System)：用于域名和IP相互映射
- 顶级域名分为：国家域、通用域和反向域
- 域名系统是一个分布式的数据库，采用客户端/服务器模型，服务器能完成域名到IP的映射或者知道去什么地方找其他域名服务器。
- 当本地域名服务器无法解析域名时，会求助于根域名服务器

**递归**：客户端只发一次请求，要求对方给出最终结果。

**迭代**：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。

**客户端-本地dns服务端：这部分属于递归查询。**

**本地dns服务端---外网：这部分属于迭代查询**

## 21.FTP

- FTP(File Transfer Protocol)：使用两个TCP连接（控制连接21、数据连接20）实现文件在远程服务器的上传和下载。

## 22.电子邮件协议

- SMTP(Simple Mail Transfer Protocol)：用于从发送方的邮件服务器发送报文到接收方的邮件服务器或发送方用户代理发送到发送方邮件服务器。
- POP3(Post Office Protocol –Version3)：用于接收方用户代理从接收方邮件服务器读取邮件。

## 23.HTTP

- WWW(World Wide Web)：万维网，一种分布式的客户/服务器资料服务，在这种方式下，客户机用浏览器能够使用服务器提供的服务。

- URL(Uniform Resource Locator)：在万维网上唯一标识一个资源。
  - 协议://主机:端口/路径

- HTTP(Hypertext Transfer Protocol)：用于在WWW上存取数据的协议。
  - 请求报文和响应报文

- HTML(Hypertext Mark Language)：用特定的标签来描述页面内容和格式。

## 24.浏览器输入网址后发生的事情

- 对网址进行DNS解析，获取IP地址

- 浏览器与服务器建立TCP连接

- 浏览器发送HTTP请求

- 服务器处理请求并返回HTTP报文

- 浏览器解析渲染页面

- 连接结束关闭连接请求

## 100.服务访问点

**服务访问点(Service Access Point)**：同一节点相邻两层的实体通过SAP进行交互。下层的SAP是上层访问下层服务的地方。

## 101.internet和Internet

- internet小写代表互联网，Internet大写代表因特网。
- internet（互联网或互连网）是一个通用名词，它泛指多个计算机网络互连而组成的网络，在这些网络之间的通信协议（即通信规则）可以是任意的。 
- Internet（因特网）则是一个专用名词，它指当前世界上最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCP/IP协议族作为通信的规则，且前身是美国的ARPANET。

## 102.什么是ISP

- Internet Service Provider 因特网服务提供商

- 一个由多个分组交换机和多段通信链路组成的网络

  通信链路：由不同类型的物理媒体组成

  分组交换机：如路由器、链路层交换机

## 103.什么是Socket

- socket其实就是操作系统提供给程序员操作**网络协议栈**的接口。

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\socket编程.jpg" style="zoom: 80%;" />

## 104.什么情况下使用多路IO

> 没看懂，抄的

- 当一个客户端需要同时处理多个文件描述符的输入输出操作的时候（一般来说是标准的输入输出和网络套接字)，I/O 多路复用技术将会有机会得到使用。
- 当程序需要同时进行多个套接字的操作的时候。
- 如果一个 TCP 服务器程序同时处理正在侦听网络连接的套接字和已经连接好的套接字。
- 如果一个服务器程序同时使用 TCP 和 UDP 协议。
- 如果一个服务器同时使用多种服务并且每种服务可能使用不同的协议（比如 inetd就是这样的）。

## 105.信道复用、多路复用、IO多路复用



# 软件工程

## 0.什么是软件工程、软件工程三要素

- **软件工程** 是研究和应用如何以系统性的、 规范化的、可定量的过程化方法去开发和维护软件，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来的学科 。

- **三要素**：方法、工具和过程。
  - **方法 **为软件开发提供了“如何做”的技术。它包括了多方面的任务，如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等。
  - **工具 **为软件工程方法提供了自动的或半自动的软件支撑环境。目前，已经推出了许多软件工具，这些软件工具集成起来，建立起称之为计算机辅助软件工程(CASE)的软件开发支撑系统。CASE将各种软件工具、开发机器和一个存放开发过程信息的工程数据库组合起来形成一个软件工程环境。
  - **过程 **则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。

## 1.黑盒测试和白盒测试

- **黑盒测试**：将测试对象看作是一个不公开透明的黑色盒子。在测试的时候，不考虑盒子里面的逻辑结果跟程序运行，只是根据程序的需求规格书来检查程序的功能是否符合它的功能说明，检验输出结果正不正确。
- **白盒测试**：利用程序内部的逻辑结构及有关信息，通过在不同点检查程序状态，对所有逻辑路径进行测试。

- **最大的区别**：关注的对象不同
  - 黑盒测试主要针对的是把程序展现给用户的功能，而白盒测试则是主要针对程序的代码逻辑。前者测试最终功能，而后者测试后台程序。
- 灰盒测试：它不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑，常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。

## 2.α测试和β测试

- **α测试**：指软件开发内部人员开始试用新产品。在实际运行环境和真实应用过程中发现测试阶段所没有发现的缺陷，是一种白盒测试。经过**Alpha测测试和修正的软件产品称为β版本**。
- **β测试**：公司外部的典型用户试用，并要求报告异常情况，提出批评意见，然后再对Beta版本进行修正和完善，最终得到正式发布的版本。是一种黑盒测试。

## 3.静态测试和动态测试

- **静态测试**：不运行程序本身而寻找程序代码中可能存在的错误或评估程序代码的过程。 
- **动态测试**：实际运行被测程序，输入相应的测试实例，检查运行结果与预期结果的差异，判定执行结果是否符合要求，从而检验程序的正确性、可靠性和有效性，并分析系统运行效率和健壮性等性能。

## 4.单元测试、集成测试、系统测试和验收测试

- 单元测试：针对软件设计的最小单位程序模块进行正确性检查的测试工作，是一种白盒测试。

- 集成测试：在单元测试的基础上，将所有的程序模块进行有序的、递增的测试。集成测试是检验程序单元或部件的接口关系，逐步集成为符合概要设计要求的程序部件或整个系统。
- 系统测试：将经过集成测试的软件与系统中其他部分结合起来，**在实际运行环境下进行一系列严格有效的测试**，以发现软件潜在的问题，保证系统的正常运行。

- 验收测试：部署软件之前的最后一个测试操作，保软件准备就绪，并且可以让最终用户将其用于执行软件的既定功能和任务。

## 5.功能、性能测试

- 功能测试：测试系统功能。

- 性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。

## 6.回归测试、冒烟测试、随机测试

- 回归测试：指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他 代码 产生错误。
- 冒烟测试：是在软件开发过程中的一种针对软件版本包的快速基本功能验证策略，是对软件基本功能进行确认验证的手段，测试的目的是确定软件是否可测试。
- 随机测试：指在测试时，抛开用例，按照对需求的理解，对功能进行随机验证，常用于功能提测时，快速发现问题。

## 7.覆盖

- 语句覆盖：每个执行语句都走一遍。
- 分支覆盖：判定真假各走一遍。
- 条件覆盖：每个条件都走一遍。

## 8.软件工程模型

- 瀑布：需求收集、分析、设计、编码、测试、维护。
- 敏捷
- V型、迭代、螺旋、原型。

## 9.软件开发过程

- 定义、开发、验收、维护。
- 定义：软件目标分析、需求分析
- 开发：软件设计、编程、测试
- 验收：软件交付、验收
- 维护：软件维护

## 10.软件体系结构风格

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\软件体系结构风格.png" style="zoom:67%;" />

# Java相关

## 1.java程序从源代码到执行经历了哪些过程？

- **编译**：.java => .class（字节码文件）
- **加载**：把.class文件装载至JVM，并做一些初始化工作
  - 比如生成类的Class对象

- **解释**：.class => 机器码
- **执行**：硬件执行

## 2.重写和重载

- 重写（Override）是父类与子类之间多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 。
  - 子类与父类**函数体内容不一样**。子类**返回的类型**必须与父类保持**一致**；子类方法可见性不能低于超类（可见性：public>protected>default>private）；子类重写方法一定不能抛出新的检查异常或者比被父类方法申明更加宽泛的检查型异常。
- 重载（Overload）是一个类中多态性的一种表现。如果在一个类中定义了多个同名的方法，它们参数列表不同，则称为方法的重载。
  - 可以有**不同的返回类型**;可以有不同的访问修饰符;可以抛出不同的异常。调用的时候根据函数的参数来区别不同的函数。

## 3.Spring 框架

- 轻量级的 Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。Spring 是存储对象的容器。
- Spring 的核心是控制反转（IoC）和面向切面编程（AOP）。
- 优点：
  - 轻量，Spring 框架运行占用的资源少，运行效率高。不依赖其他 jar。核心功能的所需的 jar 总共在 3M 左右。
  - 方便集成各种开源框架。
  - IoC，解耦合
  - AOP，声明式方式灵活地进行事务的管理，提高开发效率和质量。

### 3.1 IoC(Inversion of Control)

> 将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。

- 通过容器实现对象的创建，属性赋值，依赖的管理。
- 若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。
- Spring框架通过依赖注入(Dependency Injection)实现IoC。

***

- 依赖注入的实现方法：

  - 基于接口。实现特定接口以供外部容器注入所依赖类型的对象。

  - 基于 set 方法。实现特定属性的 public set 方法，来让外部容器调用传入所依赖类型的对象。

  - 基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。

  - 基于注解。基于 Java的注解功能 ，在私有变量前加“@Autowired”等注解，不需要显式的定义以上三种代码，便可以让外部容器传入对应的对象。

### 3.2 AOP(Aspect Oriented Programming) 面向切面

- 通过 **运行期动态代理 **实现程序功能统一维护的一种技术。
  - 代理的本质就是新建一个类，他能除了调用原始类方法完成工作，还能加一些自定义的功能。
  - 动态代理利用反射机制在运行时新建代理类，invoke原始类方法，然后加一些自定义的功能。

- 将交叉业务逻辑封装成切面，利用 AOP 容器的功能将切面织入到主业务逻辑中。
- 所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如**安全检查、事务、日志、缓存**等。若不使用 AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样，会使主业务逻辑变的混杂不清。

## 4.SpringBoot 框架

- SpringBoot是基于 Spring 开发的一种轻量级框架
  - 继承了 Spring 框架原有的优秀特性。
  - 通过简化配置来进一步简化了 Spring 应用的整个搭建和开发过程。
- 特点：
  - 内嵌Tomcat
  - POM文件简化Maven配置
  - 尽可能自动配置Spring容器
  - **减少了大量的XML配置**
  - 可以创建独立的 Spring 应用程序，并且基于其 Maven 或 Gradle 插件，可以创建可执行的 JARs 和 WARs。

## 5.什么是微服务

- 将一个系统按业务划分成多个子系统，每个子系统都是完整的，可独立运行的。
- 子系统间的交互可通过HTTP协议进行通信（也可以采用消息队列来通信，如RocketMQ，Kafaka等）。

- 不同子系统可以使用不同的编程语言实现，使用不同的存储技术。

***

- 需要集中化管理，例如Eureka，Zookeeper等都是比较常见的服务集中化管理框架

- 微服务的优势
  - 独立开发：基于各个微服务所独有的功能，它们可以被轻易开发出来。
  - 独立部署：基于它们所提供的服务，它们可以被独立地部署到应用中。
  - 错误隔离：即便其中某个服务发生了故障，整个系统还可以继续工作。
  - 混合技术栈：可以使用不同的语言和技术来为同一个应用构建不同的服务。
  - 按粒度扩展：可以根据需求扩展某一个组件，不需要将所有组件全部扩展。

## 6.Vue框架

- Vue是一套用于构建用户界面的**渐进式框架**。
  - 即没有多做职责之外的事。vue.js只提供了vue-cli生态中最核心的 **组件系统** 和 **双向数据绑定**。
- Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。

- **MVVM框架**(Model-View-ViewModel)
  - View通过View-Model的DOM Listeners将事件绑定到Model上
  - 而Model则通过Data Bindings来管理View中的数据
  - View-Model从中起到一个连接桥的作用。

- 通过MVVM实现双向数据绑定
  - Model 和 ViewModel 之间的交互是双向的， View 的变化会同步到 Model，而 Model 的变化也会立即同步到 View 上。

## 7.WebSocket

- HTML5定义的网络通信协议，可在单个 TCP 连接上进行全双工通信。

- WebSocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。
- WebSocket 只需要建立一次连接，就可以一直保持连接状态。

> 连接建立方式

- 客户端浏览器首先向服务器发起一个 HTTP 请求，包含了一些附加头信息，其中"Upgrade: WebSocket"表明这是一个申请协议升级的 HTTP 请求
- 服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了
- 双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。

## 8.java垃圾回收机制(Garbage Collection)

- [Java垃圾回收详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/163693285#:~:text=在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。,这也就造成了垃圾回收所谓的 暂停时间（GC pause） 。)

### 8.1 可达性分析

> Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。它从一系列 GC Roots 出发，边标记边探索所有被引用的对象。

- 引用计数法的缺点：假设对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。
- **可达性分析**：将一系列 **GC Roots** 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。
- **GC Roots**：可以暂时理解为由堆外指向堆内的引用。包括但不限于：
  - Java 方法栈桢中的局部变量；
  - 已加载类的静态变量；
  - **JNI handles**；
  - 已启动且未停止的 Java 线程。

### 8.2 回收策略

> 回收死亡对象的内存共有三种方式，分别为：会造成内存碎片的**清除**、性能开销较大的**压缩**、以及堆使用效率较低的**复制**。

- **清除（sweep**），即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。
  - 会造成内存碎片，因为Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。
  - 分配效率低，如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。

<img src="C:\Users\Lenovo\Desktop\面试复习图片\JVM垃圾回收机制_清理.jpg" style="zoom:50%;" />

- **压缩（compact）**，即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。
  - 代价是压缩算法的性能开销。

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\JVM垃圾回收机制_压缩.jpg" style="zoom: 50%;" />

- **复制（copy）**，即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\JVM垃圾回收机制_复制.jpg" style="zoom:50%;" />

> Java 虚拟机将堆分为新生代和老年代，并且对不同代采用不同的垃圾回收算法。

- **大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间。**
- 所以，将堆空间划分为两代，分别叫做**新生代**和**老年代**。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。
- 对于新生代，我们猜测大部分的 Java 对象只存活一小段时间，那么便可以 **频繁地采用耗时较短的垃圾回收算法**，让大部分的垃圾都能够在新生代被回收掉。
- 对于老年代，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。这时候，Java 虚拟机往往需要做一次**全堆扫描，耗时也将不计成本**。

***

- 新生代分为 Eden 区（伊甸园）和两个大小一致的 Survivor 区（幸存者），并且其中一个 Survivor 区是空的。在只针对新生代的 Minor GC 中，Eden 区和非空 Survivor 区的存活对象会被复制到空的 Survivor 区中，当 Survivor 区中的存活对象复制次数超过一定数值时，它将被晋升至老年代。

- 当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。


<img src="C:\Users\Lenovo\Desktop\面试复习图片\JVM垃圾回收机制_新生代和老生代.jpg" style="zoom:50%;" />

- 当 Eden 区的空间耗尽时，Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。
- 当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。
- Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15，那么该对象将被晋升（promote）至老年代。
- 另外，如果单个 Survivor 区已经被占用了 50%，那么较高复制次数的对象也会被晋升至老年代。
- 总而言之，当发生 Minor GC 时，我们应用了**标记 - 复制算法**，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。
- 老年代的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。

***

- 因为 Minor GC 只针对新生代进行垃圾回收，所以在枚举 GC Roots 的时候，它需要考虑从老年代到新生代的引用。为了避免扫描整个老年代，Java 虚拟机引入了名为 **卡表** 的技术，大致地标出可能存在老年代到新生代引用的内存区域。
- **卡表**技术 将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡**是否可能存有指向新生代对象的引用**

- 如果可能存在，那么我们就认为这张卡是脏的。在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。

### 8.3 Stop-the-world策略

> 为了防止在标记过程中堆栈的状态发生改变，Java 虚拟机采取安全点机制来实现 Stop-the-world 操作，暂停其他非垃圾回收线程。

- 可达性分析的缺点：在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。
  - 误报可能会使虚拟机损失部分垃圾回收的机会。
  - 漏报可能会使虚拟机回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。
- 为了防止**漏报**：JVM会采用Stop-the-world方法，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的**暂停时间（GC pause）**。
- Stop-the-world 是通过**安全点（safepoint）机制**来实现的。当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。
- **安全点**：Java 虚拟机的堆栈不会发生变化的状态。包括：
  - JNI执行本地代码、解释执行字节码、执行即时编译器生成的机器码和线程阻塞。

### 8.4 总结一下吧

- JVM垃圾回收机制的核心概念：可达性分析、回收策略和安全。
  - 从初始GC Roots集合开始探索所有能够被该集合引用到的对象，将其标记并加入该集合。集合外的对象被判定为死亡。
  - 三种回收策略：将死亡对象的内存空间标记为空闲、压缩碎片空闲空间、分两个内存空间，每次都将非空闲区的对象复制到空闲区，原非空闲区置空。
  - 分新老生代：老生代采用全栈扫描来进行GC。新生代频繁进行耗时较短的GC。新生代的Eden+Survivors from区和Survivors to区采用复制GC策略。
  - 为了防止GC过程的误报漏报问题，在安全点采用Stop-the-world机制，让GC进程进行独占工作。



## 9.JVM内存管理机制

- JVM在执行Java程序的过程中会把它所管理的内存划分为5个不同的数据区域。**5区域存储不同类型的数据**，**5区域的内存分配和销毁的时间也不同**，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。
  - 堆、方法区、JVM栈、本地方法栈、程序计数器。

<img src="C:\Users\Lenovo\Desktop\TyporaAll\Typora图片\JVM内存分配区.jpg" style="zoom: 10%;" />

- **方法区：**存储类信息和方法信息，被所有线程共享。具体包括：方法、成员变量、**全局变量(static修饰)、常量、Class对象**。

- **堆区：**JVM只有一个heap区，被所有线程共享，**存储new出来的对象本身**，每个对象都包含一个与之对应的Class信息。
  
  - 注：jvm垃圾回收区域主要是堆区，由程序员申请和释放，如果程序员没有释放，将一直存在直至程序运行结束。
  
- **栈：**每个线程有一个stack区，存储方法内部的**局部变量、基本数据类型、堆中对象的引用**。
  
  - 栈分为3部分：基本类型变量区、执行环境上下文、操作指令区。
  
  - 注：对于栈空间，最后会自动释放资源，所以不需要垃圾回收。
  
- 在java中，声明的对象是先在**栈内存**中为其**开辟内存空间**，在对其进行实例化后则在**堆内存**中为其**分配内存地址**。

## 10. 封装、继承、多态、抽象

- **封装**：把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。
  - 隐藏实现细节、安全、复用、模块化
- **继承**：从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。
- **多态**：为不同数据类型的实体提供统一的接口。
  - 利于扩展
- **抽象**：通过特定的实例抽取出共同的特征形成概念的过程。

## 11.java类实例初始化过程

- 执行顺序：

  （1）父类静态代码块与静态成员

  （2）子类静态代码块与静态成员

  （3）父类普通成员变量和代码块

  （4）父类构造方法

  （5）子类普通成员变量和代码块

  （6）子类构造方法

- 记忆：静态优先，父先于子，先初始化成员变量和代码块，再执行构造器主体。

## 12.final和static的区别

- 二者都可以修饰类、成员方法、成员变量。
- static可以修饰类的代码块（静态代码块），final可以修饰方法内的局部变量。

> 区别

- static修饰的变量可以重新赋值。final修饰表示常量，一旦创建不可改变且声明时必须赋值，或在类的构造方法中赋值，不可以重新赋值。
- static修饰的方法必须被实现。final方法不能被子类重写。
- static修饰的类是静态内部类 。final类不能被继承，final类中的方法默认是final的。



# 机器学习

## 1.梯度爆炸和梯度消失

- 在反向传播过程中需要对激活函数进行求导，如果导数大于1，那么随着网络层数的增加梯度更新将会朝着指数爆炸的方式增加这就是梯度爆炸。同样如果导数小于1，那么随着网络层数的增加梯度更新信息会朝着指数衰减的方式减少这就是梯度消失。因此，梯度消失、爆炸，其根本原因在于反向传播训练法则，属于先天不足。
- 解决方法：
  - 对于RNN，可以通过梯度截断，避免梯度爆炸。
  - 可以通过添加**正则项**，避免梯度爆炸。
  - 使用LSTM等自循环和门控制机制，避免梯度消失。
  - 优化**激活函数**，譬如将 sigmoid改为relu，避免梯度消失。

## 2.数据挖掘

- 数据挖掘三大常见的任务：
  - 回归任务：回归任务是一种对连续型随机变量进行预测和建模的监督学习算法。
  - 分类任务：分类是一种对离散型变量建模或预测的监督学习算法，使用案例包括邮件过滤、金融欺诈等。
    - 线性判别分析、朴素贝叶斯分类器、支持向量机、最近邻算法、决策树、神经网络。
  - 聚类任务：聚类是一种无监督学习，它会试图识别数据本身的内部结构，使用案例包括新闻聚类、文章推荐等。
    - 常见的聚类算法：基于划分的聚类（K-means）、基于密度的聚类（DBSCAN）、层次聚类（合并、分裂）。

## 3.PCA

- 通过某种线性投影，将高维的数据映射到低维的空间中表示，并期望在所投影的维度上数据的方差最大，以此使用较少的数据维度，同时保留住较多的原数据点的特性。
- 流程：样本中心化、计算样本的协方差矩阵、对协方差矩阵做特征值分解、保留最大的d个特征值对应的特征向量作为投影子空间。

## 4.回归

- 回归：从大量的函数结果和自变量反推回函数表达式的过程。
- 线性回归：目标值预期是输入变量的线性组合。
- 逻辑回归：主要用于分类任务，是使用逻辑函数将线性回归的结果归一化的分类模型。

## 5.K-means算法

- 随机选取k个初始点为质心，并通过计算每一个样本与质心之间的相似度（可以采用欧式距离），将样本点归到最相似的类中，接着重新计算每个类的质心（该类中所有点的平均值），重复这样的过程直到质心不再改变。

## 6.KNN算法

- 每个样本都可以用它最接近的k个邻居中大多数样本所属的类别来代表。

## 7.决策树

- 本质是一颗由多个判断节点组成的树。在使用模型进行预测时，根据输入参数依次在各个判断节点进行判断游走，最后到叶子节点即为预测结果。
- 构建过程：
  - 遍历每个决策条件，对结果集进行拆分。
  - 计算在该决策条件下，所有可能的拆分情况的信息增益，信息增益最大的拆分为本次最优拆分。
  - 递归执行1、2两步，直至信息增益 <= 0。

## 8.SVM

- SVM是一个二类分类器，它的目标是找到一个超平面，使用两类数据离超平面越远越好。

- 支持向量：离分类超平面距离最近且相等的样本点。
- 寻找最大间隔：求使支持向量到超平面距离最大的分隔超平面。
- 求解方法：将目标函数和不等式约束 通过 拉格朗日乘子法转换为对偶问题，求解对偶问题，对偶问题的解就是原始问题的解。
  - KKT条件表明最终的超平面只和支撑向量有关系。

## 9.朴素贝叶斯

- 贝叶斯决策理论的核心思想，就是选择最高概率的决策。
- 这里的后验概率：在已知样本x的情况下，是y~k~的概率。
- 转换为先验概率*似然度：先验概率和似然度由样本空间算得。

- 前提假设：特征条件独立

## 10.最小二乘法

- 通过最小化误差的平方和，使得拟合对象最大限度逼近目标对象。
- 化为矩阵表示，损失函数J($\theta$) = (X$\theta$ - Y)^T^(X$\theta$ - Y) / 2。对$\theta$ 求偏导，得$\theta$  = (X^T^X)^-1^X^T^Y。

## 11.梯度下降法

- 梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向。

- 批量梯度下降法：每次迭代时都使用全部样本。
- 随机梯度下降法：每次迭代时，只使用一个样本。
- 小批量梯度下降法：每次迭代时都使用一部分样本来进行更新，可以选择对每个batch的梯度进行累加，或者取平均值。取平均值可以减少梯度的方差。

## 12.奇异值分解

- A是一个m*n的矩阵，A = U$\sum$V^T^。
- V是A^T^A的特征向量组，U是AA^T^的特征向量组。
- 奇异值矩阵是主对角线为奇异值的对角阵，AV = U$\sum$。

## 13.协同过滤

- 协同过滤推荐方法主要通过 **对用户的所有购物历史记录进行建模与挖掘以捕获用户的总体偏好** ,再基于用户的总体偏好提供物品推荐
- 分为 **基于记忆** 的协同过滤方法与 **基于模型** 的协同过滤方法两类
- **基于记忆的协同过滤方法(Memory-based CF)**：采用特定的相似度评估方法计算用户或物品的K最近邻群体,然后基于最近邻群体的协同偏好特征提供物品推荐。
  - 常用的相似度评估方法：Pearson相关相似度计算和余弦相似度计算
  - 包括 **基于用户的协同过滤** 和 **基于物品的协同过滤**
    - 基于用户的CF：一个用户喜欢与他兴趣爱好相似的用户喜欢的物品
    - 基于物品的CF：用户可能会喜欢与他/她之前喜欢的物品相似的物品
  - 基于用户流行度的协同过滤算法和基于物品流行度的协同过滤算法,分别融合了时间信息的用户近况感知特性以及物品的流行度特性,通过考虑时间信息,基于记忆的协同过滤方法能够有效捕获用户购物行为中存在的重复性和忠诚性因素。
- **基于模型的协同过滤方法**：将用户与物品的交互数据作为训练数据,通过训练模型（机器学习或数据挖掘等模型）以学习与识别隐藏在交互数据中的复杂关联关系,从而获得融合用户总体兴趣偏好的推荐预测模型,最后基于推荐预测模型在新的交互数据上进行商品推荐。
  - 通过模型的有监督训练,能够学习到潜在的用户总体偏好嵌入表达,且能够捕获更加复杂的关联关系。

## 14.关联规则分析

- 从用户历史购物篮交易记录中挖掘物品的频繁样式,然后利用挖掘出的频繁样式作为指导以解决下一购物篮预测问题
- 包含 **关联样式挖掘** 的方法与 **序列样式挖掘** 的方法两种。
- **关联样式挖掘**：挖掘频繁项集（基于先验原理的Apriori 算法）、生成规则（支持度和置信度）
  - 先验原理：如果一个项集X是频繁的，则它的所有非空子集一定也是频繁的。如果一个项集X是非频繁的，则它的所有超集也是非频繁的。
  - 频繁项集：支持度大于最小支持度阈值的项集
  - 强关联规则：同时满足最小支持度阈值和最小置信度阈值的规则
  - **项（或项集）X 的支持度 (sup)**  是包含项（或项集） X 的事务数与总事务数 (#𝐷)的比值
  - **规则的支持度(sup) **是数据库 *D* 中包含项集 X 和项集 Y 的事务数与数据库 *D* 中的事务数的比
  - **规则的置信度(conf)** 指在数据库 *D* 中同时包含两个项集 {X, Y} 的事务数与包含项集X的事务数的比率
  - 能有效捕获在同一购物篮内物品之间的共现关系与频率特征
- **序列样式挖掘**：寻找的是购物篮之间**时间**上的相关性，也可分解为频繁样式挖掘与关联规则生成两个阶段。
  - 是对同一个用户的不同购物篮中物品之间关联规则的分析与挖掘,旨在捕获不同购物篮间的序列化依赖关系与频率特征。

## 15.马尔可夫链

- **基于马尔可夫链的方法**：主要由转移矩阵构建与因子分解推荐两个构件组成
  - **转移矩阵构建** 根据用户上一时刻与当前时刻的交互行为数据构造用户的转移矩阵,以建模上一时刻与当前时刻购物之间的序列化依赖关系;
  - **因子分解推荐** 基于构建后的用户个性化转移矩阵实现基于协同过滤的物品集合推荐,实现对用户总体偏好的挖掘
  - **马尔可夫链**：状态空间中经过从一个状态到另一个状态的转换的随机过程，该过程要求具备“**无记忆性** ”，即下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“**无记忆性** ”称作马尔可夫性质。
    - 马尔可夫链认为**过去所有的信息都被保存在了现在的状态下了**。

![](C:/Users/Lenovo/Desktop/TyporaAll/Typora%E5%9B%BE%E7%89%87/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE.png)

## 16.RNN及其变体

- RNN循环神经网络：h^t^ = $\sigma$(W^h^h^t-1^ + W^i^x);    y^t^ = $\sigma$(W^o^h^t^).
- LSTM长短期记忆模型：c^t^ = c^t-1^$\odot$z^f^ + z$\odot$z^i^;    h^t^ = z^o^$\odot$ tanh(c^t^);  y^t^ = $\sigma$(W^o^h^t^).
  - 输入和门控都是由上一时刻的隐状态和当前输入得到的（向量拼接+乘权重+激活）。
  - 遗忘门控、输入门控、输出门控、隐状态、细胞状态。
  - 为了解决RNN训练过程中的梯度爆炸和梯度消失问题，加入门控机制。

- GRU门控循环单元：h^t^ = (1-z^u^)$\odot$h^t-1^ + z^u^$\odot$h';.
  - 门控都是由上一时刻的隐状态和当前输入得到的，输入是由重置过的上一时刻隐状态和当前输入得到的。
  - 重置门控可以看做是上一阶段的输出门控，更新门控是遗忘+输入门控。

- 由sigmoid激活，结果在0~1之间，表示选择记忆，选择遗忘的门控。
- 由tanh激活，结果在-1~1之间，表示信息。

## 100.矩阵稀疏性怎么解决

- 降维（奇异值分解）
- 协同过滤推荐
- 压缩处理



# 其他知识

## 1.c程序从源代码到二进制程序都经历了那些过程？

- **预处理**：将所有的#include头文件以及宏定义替换成其真正的内容。=>文本文件( .i)
- **编译**：转换成特定汇编代码。=> 文本文件( .s)
- **汇编**：汇编代码转换成机器码。=> 二进制格式的目标文件( .o)
- **链接**：将多个目标文件以及所需的库文件(.so等)链接。 => 可执行文件

## 2.递归和循环

> 区别

- 递归需要维护一个栈，所以运算规模小，循环运算规模大。
- 递归复用的是函数，循环复用的是语句。
- 循环运行效率高，占用空间小。递归因为要函数入栈出栈，运行效率低，占用空间大。
- 多重循环可读性差，递归表达的比较简洁。

>  联系

- 本质上都是代码复用
- 具有相同的计算能力

## 3.指针和引用的区别

- 指针是一个变量，存储的是一个地址，指向内存的一个存储单元；

- 引用是原变量的一个别名，跟原来的变量实质上是同一个东西；
- 指针可以在定义的时候不初始化，引用必须在定义的时候初始化；
- 指针可以指向NULL，引用不可以为NULL；
- 指针初始化之后可以再改变，引用不可以；

## 4.深拷贝和浅拷贝的区别

- 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
- 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
- 使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。

## 5.写时复制(Copy-on-write)

Copy-on-write是解决并发的的一种思路，指的是实行读写分离，如果执行的是写操作，则复制一个新集合，在新集合内添加或者删除元素。待一切修改完成之后，再将原集合的引用指向新的集合。

## 6.C++内存区域

- C++内存区域分为5个区域。分别是堆，栈，自由存储区，全局/静态存储区和常量存储区。

- 栈：由编译器在需要的时候分配，在不需要的时候自动清除的变量存储区。里面通常是局部变量，函数参数等。

- 堆：由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

- 自由存储区：由malloc等分配的内存块，和堆十分相似，不过它使用free来结束自己的生命。

- 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的c语言中。全局变量又分为初始化的和未初始化的，在c++里面没有这个区分了，他们共同占用同一块内存。

- 常量存储区：这是一块比较特殊的存储区，里面存放的是常量，不允许修改。



## 100.单例模式

- 指一个类只有一个实例，且该类能自行创建这个实例的一种模式。
- 单例模式有 3 个特点：
  1. 单例类只有一个实例对象；
  2. 该单例对象必须由单例类自行创建；
  3. 单例类对外提供一个访问该单例的全局访问点。
- spring中默认bean就是单例的。
- 相对的是原型模式，用同一id会获取不同的对象。

## 101.设计模式6条原则

- 单一职责原则(Single Responsibility Principle/SRP)：应该有且仅有一个原因引起类的变更；
- 里氏替换原则(Liskov Substitution Principle/LSP)：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类；
  - 多态
- 依赖倒置原则(Dependency Inversion Principle/DIP)：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；
  - 要接口
- 接口隔离原则(Interface Segregation Principle/ISP)：类间的依赖关系应该建立在最小的接口上；
  - 接口要小
- 迪米特法则(Law of Demeter/LoD)：类间解耦；
  - 低耦合
- 开放封闭原则(Open Close Principle/OCP)：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化。
